{"/home/travis/build/npmtest/node-npmtest-phaser-tiled/test.js":"/* istanbul instrument in package npmtest_phaser_tiled */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-phaser-tiled/lib.npmtest_phaser_tiled.js":"/* istanbul instrument in package npmtest_phaser_tiled */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_phaser_tiled = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_phaser_tiled = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-phaser-tiled/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-phaser-tiled && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_phaser_tiled */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_phaser_tiled\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_phaser_tiled.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_phaser_tiled.rollup.js'] =\n            local.assetsDict['/assets.npmtest_phaser_tiled.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_phaser_tiled.__dirname + '/lib.npmtest_phaser_tiled.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-phaser-tiled/node_modules/phaser-tiled/src/index.js":"module.exports = {\n    utils: require('./utils')\n};\n","/home/travis/build/npmtest/node-npmtest-phaser-tiled/node_modules/phaser-tiled/src/utils.js":"var zlib    = require('zlibjs');\nvar Buffer  = require('buffer').Buffer;\n\nvar decodeB64 = (typeof window !== 'undefined' && window.atob) || require('Base64').atob;\n\nvar utils = module.exports = {};\n\nutils.destroyTexture = function (texture, callDestroy) {\n    if (callDestroy !== false) {\n        texture.destroy();\n    }\n\n    texture.baseTexture = null;\n    texture.frame = null;\n    texture.trim = null;\n    texture.crop = null;\n    texture._uvs = null;\n};\n\nutils.stringToBuffer = function (str) {\n    var len = str.length;\n    var buf = new Buffer(len);\n\n    for (var i = 0; i < len; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n\n    return buf;\n};\n\nutils.cacheKey = function (key, type, name) {\n    return key + '_' + type + (name ? '_' + name : '');\n};\n\nutils.decompressBase64Data = function (raw, encoding, compression) {\n    // TODO: This assumes base64 encoding, need to check encoding param\n    var str = decodeB64(raw);\n    var buf = utils.stringToBuffer(str);\n\n    // decompress\n    if (compression === 'gzip') {\n        return zlib.gunzipSync(buf);\n    }\n    else if (compression === 'zlib') {\n        return zlib.inflateSync(buf);\n    }\n\n    return buf;\n};\n\n/**\n * Parses an array of numbers that represent a hitArea into the actual shape.\n *\n * For example: `[1, 1, 15]` is a Circle (`[x, y, radius]`); `[1, 1, 15, 15]` is a Rectangle\n * (`[x, y, width, height]`); and any length >= 5 is a polygon in the form `[x1, y1, x2, y2, ..., xN, yN]`.\n *\n * @method parseHitArea\n * @param value {Array<Number>} The array to parse\n * @return {Circle|Rectangle|Polygon} The parsed out shape\n */\nutils.parseHitArea = function (hv) {\n    var shape;\n\n    // odd number of values\n    if (hv.length % 2 !== 0 && hv.length !== 3) {\n        throw new RangeError(\n            'Strange number of values for hitArea! Should be a flat array of values, like: ' +\n            '[cx,cy,di] for a circle, [x,y,w,h] for a rectangle, or [x,y,x,y,...] for other polygons.'\n        );\n    }\n\n    // a circle x,y,r\n    if (hv.length === 3) {\n        shape = new Phaser.Circle(hv[0], hv[1], hv[2]);\n    }\n    // a rectangle x,y,w,h\n    else if (hv.length === 4) {\n        shape = new Phaser.Rectangle(hv[0], hv[1], hv[2], hv[3]);\n    }\n    // generic polygon\n    else {\n        shape = new Phaser.Polygon(hv);\n    }\n\n    return shape;\n};\n\n/**\n * Parses an object of string properties into potential javascript types. First it attempts to\n * convert to a number, if that fails it checks for the string 'true' or 'false' and changes it\n * to the actual Boolean value, then it attempts to parse a string as JSON.\n *\n * @method parseTiledProperties\n * @param value {Array<Number>} The array to parse\n * @return {Circle|Rectangle|Polygon} The parsed out shape\n */\nutils.parseTiledProperties = function (obj) {\n    obj = obj || {};\n\n    if (!obj || obj.__tiledparsed) {\n        return obj;\n    }\n\n    for (var k in obj) {\n        var v = obj[k];\n        var n = parseFloat(v, 10);\n\n        // try to massage numbers\n        if (n === 0 || n) {\n            obj[k] = n;\n        }\n        // true values\n        else if (v === 'true') {\n            obj[k] = true;\n        }\n        // false values\n        else if (v === 'false') {\n            obj[k] = false;\n        }\n        // anything else is either a string or json\n        else {\n            try {\n                v = JSON.parse(v);\n                obj[k] = v;\n            } catch (e) {\n                // ignore error\n            }\n        }\n    }\n\n    if (obj.hitArea) {\n        obj.hitArea = utils.parseHitArea(obj.hitArea);\n    }\n\n    if (obj.body === 'static' || obj.sensor) {\n        obj.mass = Infinity;\n        obj.inertia = Infinity;\n    }\n\n    obj.__tiledparsed = true;\n\n    return obj;\n};\n","/home/travis/build/npmtest/node-npmtest-phaser-tiled/node_modules/phaser-tiled/src/browser.js":"var utils = require('./utils');\nvar physics = require('./physics');\n\n/**\n * @class Phaser.Plugin.Tiled\n * @classdesc Phaser - Tiled Plugin\n *\n * @constructor\n * @extends Phaser.Plugin\n *\n * @param {Phaser.Game} game - A reference to the currently running game.\n * @param {Any} parent - The object that owns this plugin, usually Phaser.PluginManager.\n */\nfunction Tiled(game, parent) {\n    Phaser.Plugin.call(this, game, parent);\n}\n\n//  Extends the Phaser.Plugin template, setting up values we need\nTiled.prototype = Object.create(Phaser.Plugin.prototype);\nTiled.prototype.constructor = Tiled;\n\nmodule.exports = Tiled;\n\n// Tiled.Tile          = require('./tiled/Tile');\nTiled.Tileset       = require('./tiled/Tileset');\nTiled.Tilemap       = require('./tiled/Tilemap');\nTiled.Tilelayer     = require('./tiled/Tilelayer');\nTiled.Objectlayer   = require('./tiled/Objectlayer');\nTiled.utils         = utils;\n\nvar originals = {\n    gameObjectFactory: {\n        tiledmap: Phaser.GameObjectFactory.prototype.tiledmap\n    },\n    loader: {\n        tiledmap: Phaser.Loader.prototype.tiledmap,\n        loadFile: Phaser.Loader.prototype.loadFile,\n        jsonLoadComplete: Phaser.Loader.prototype.jsonLoadComplete,\n        xmlLoadComplete: Phaser.Loader.prototype.xmlLoadComplete,\n        processPack: Phaser.Loader.prototype.processPack\n    },\n    physics: {\n        p2: {\n            convertTiledmap: Phaser.Physics.P2 ? Phaser.Physics.P2.prototype.convertTiledmap : null,\n            convertTiledCollisionObjects: Phaser.Physics.P2 ? Phaser.Physics.P2.prototype.convertTiledCollisionObjects : null\n        },\n        ninja: {\n            convertTiledmap: Phaser.Physics.Ninja ? Phaser.Physics.Ninja.prototype.convertTiledmap : null\n        }\n    }\n};\n\nTiled.prototype.init = function () {\n    Phaser.GameObjectFactory.prototype.tiledmap = GameObjectFactory_tiledmap;\n    Phaser.Loader.prototype.tiledmap = Loader_tiledmap;\n    Phaser.Loader.prototype.loadFile = Loader_loadFile;\n    Phaser.Loader.prototype.jsonLoadComplete = Loader_jsonLoadComplete;\n    Phaser.Loader.prototype.xmlLoadComplete = Loader_xmlLoadComplete;\n    Phaser.Loader.prototype.processPack = Loader_processPack;\n\n    if (Phaser.Physics.P2) {\n        Phaser.Physics.P2.prototype.convertTiledmap = physics.p2.convertTiledmap;\n        Phaser.Physics.P2.prototype.convertTiledCollisionObjects = physics.p2.convertTiledCollisionObjects;\n    }\n\n    if (Phaser.Physics.Ninja) {\n        Phaser.Physics.Ninja.prototype.convertTiledmap = physics.ninja.convertTiledmap;\n    }\n};\n\nTiled.prototype.destroy = function () {\n    Phaser.Plugin.prototype.destroy.apply(this, arguments);\n\n    Phaser.GameObjectFactory.prototype.tiledmap = originals.gameObjectFactory.tiledmap;\n    Phaser.Loader.prototype.tiledmap = originals.loader.tiledmap;\n    Phaser.Loader.prototype.loadFile = originals.loader.loadFile;\n    Phaser.Loader.prototype.jsonLoadComplete = originals.loader.jsonLoadComplete;\n    Phaser.Loader.prototype.xmlLoadComplete = originals.loader.xmlLoadComplete;\n    Phaser.Loader.prototype.processPack = originals.loader.processPack;\n\n    if (originals.physics.p2.convertTiledmap) {\n        Phaser.Physics.P2.prototype.convertTiledmap = originals.physics.p2.convertTiledmap;\n        Phaser.Physics.P2.prototype.convertTiledCollisionObjects = originals.physics.p2.convertTiledCollisionObjects;\n    }\n\n    if (originals.physics.ninja.convertTiledmap) {\n        Phaser.Physics.Ninja.prototype.convertTiledmap = originals.physics.ninja.convertTiledmap;\n    }\n};\n\nfunction GameObjectFactory_tiledmap(key, group) {\n    return new Tiled.Tilemap(this.game, key, group);\n}\n\n/**\n * Add a new tilemap loading request.\n *\n * @method Phaser.Loader#tilemap\n * @param {string} key - Unique asset key of the tilemap data.\n * @param {string} [url] - The url of the map data file (csv/json)\n * @param {object} [data] - An optional JSON data object. If given then the url is ignored and this JSON\n *      object is used for map data instead.\n * @param {number} [format=Tiled.Tilemap.CSV] - The format of the map data. Either Tiled.Tilemap.CSV\n *      or Tiled.Tilemap.TILED_JSON.\n * @return {Phaser.Loader} This Loader instance.\n */\nfunction Loader_tiledmap(key, url, data, format) {\n    if (typeof format === 'undefined') { format = Tiled.Tilemap.CSV; }\n\n    /*eslint-disable no-eq-null, eqeqeq */\n    if (url == null && data == null) {\n        console.warn('Phaser.Loader.tiledmap - Both url and data are null. One must be set.');\n\n        return this;\n    }\n    /*eslint-enable no-eq-null, eqeqeq */\n\n    //  A map data object has been given\n    if (data) {\n        switch (format) {\n            //  A csv string or object has been given\n            case Tiled.Tilemap.CSV:\n                break;\n\n            //  A json string or object has been given\n            case Tiled.Tilemap.TILED_JSON:\n                if (typeof data === 'string') {\n                    data = JSON.parse(data);\n                }\n                break;\n\n            //  An xml string or document has been given\n            case Tiled.Tilemap.TILED_XML:\n                if (typeof data === 'string') {\n                    data = utils.parseXML(data);\n                }\n                break;\n        }\n\n        this.game.cache.addTilemap(key, null, data, format);\n    }\n    else {\n        this.addToFileList('tiledmap', key, url, { format: format });\n    }\n\n    return this;\n}\n\nfunction Loader_loadFile(file) {\n    originals.loader.loadFile.apply(this, arguments);\n\n    if (file.type === 'tiledmap') {\n        if (file.format === Tiled.Tilemap.TILED_JSON) {\n            this.xhrLoad(file, this.transformUrl(file.url, file), 'text', this.jsonLoadComplete);\n        }\n        else if (file.format === Tiled.Tilemap.CSV) {\n            this.xhrLoad(file, this.transformUrl(file.url, file), 'text', this.csvLoadComplete);\n        }\n        else if (file.format === Tiled.Tilemap.TILED_XML) {\n            this.xhrLoad(file, this.transformUrl(file.url, file), 'text', this.xmlLoadComplete);\n        }\n        else {\n            this.asyncComplete(file, 'invalid Tilemap format: ' + file.format);\n        }\n    }\n}\n\n/**\n * Successfully loaded a JSON file.\n *\n * @method Phaser.Loader#jsonLoadComplete\n * @param {object} file - File associated with this request\n * @param {XMLHttpRequest} xhr\n */\nfunction Loader_jsonLoadComplete(file, xhr) {\n    var data = JSON.parse(xhr.responseText);\n\n    if (file.type === 'tilemap' || file.type === 'tiledmap')\n    {\n        this.game.cache.addTilemap(file.key, file.url, data, file.format);\n    }\n    else if (file.type === 'json')\n    {\n        this.game.cache.addJSON(file.key, file.url, data);\n    }\n    else\n    {\n        this.game.cache.addTextureAtlas(file.key, file.url, file.data, data, file.format);\n    }\n\n    this.asyncComplete(file);\n}\n\n/**\n * Successfully loaded an XML file.\n *\n * @method Phaser.Loader#xmlLoadComplete\n * @param {object} file - File associated with this request\n * @param {XMLHttpRequest} xhr\n */\nfunction Loader_xmlLoadComplete(file, xhr) {\n    // Always try parsing the content as XML, regardless of actually response type\n    var data = xhr.responseText;\n    var xml = this.parseXml(data);\n\n    if (!xml)\n    {\n        var responseType = xhr.responseType || xhr.contentType; // contentType for MS-XDomainRequest\n        console.warn('Phaser.Loader - ' + file.key + ': invalid XML (' + responseType + ')');\n        this.asyncComplete(file, 'invalid XML');\n        return;\n    }\n\n    if (file.type === 'tilemap' || file.type === 'tiledmap') {\n        this.game.cache.addTilemap(file.key, file.url, xml, file.format);\n    }\n    else if (file.type === 'bitmapfont')\n    {\n        this.game.cache.addBitmapFont(file.key, file.url, file.data, xml, file.xSpacing, file.ySpacing);\n    }\n    else if (file.type === 'textureatlas')\n    {\n        this.game.cache.addTextureAtlas(file.key, file.url, file.data, xml, file.format);\n    }\n    else if (file.type === 'xml')\n    {\n        this.game.cache.addXML(file.key, file.url, xml);\n    }\n\n    this.asyncComplete(file);\n\n}\n\n// the same as the core one, but we add 'tiledmap'\nfunction Loader_processPack(pack) {\n    var packData = pack.data[pack.key];\n\n    if (!packData)\n    {\n        console.warn('Phaser.Loader - ' + pack.key + ': pack has data, but not for pack key');\n        return;\n    }\n\n    for (var i = 0; i < packData.length; i++)\n    {\n        var file = packData[i];\n\n        switch (file.type)\n        {\n            case 'image':\n                this.image(file.key, file.url, file.overwrite);\n                break;\n\n            case 'text':\n                this.text(file.key, file.url, file.overwrite);\n                break;\n\n            case 'json':\n                this.json(file.key, file.url, file.overwrite);\n                break;\n\n            case 'script':\n                this.script(file.key, file.url, file.callback, pack.callbackContext || this);\n                break;\n\n            case 'binary':\n                this.binary(file.key, file.url, file.callback, pack.callbackContext || this);\n                break;\n\n            case 'spritesheet':\n                this.spritesheet(file.key, file.url, file.frameWidth, file.frameHeight,\n                        file.frameMax, file.margin, file.spacing);\n                break;\n\n            case 'audio':\n                this.audio(file.key, file.urls, file.autoDecode);\n                break;\n\n            case 'audiosprite':\n                this.audio(file.key, file.urls, file.jsonURL);\n                break;\n\n            case 'tilemap':\n                this.tilemap(file.key, file.url, file.data, Phaser.Tilemap[file.format]);\n                break;\n\n            case 'tiledmap':\n                this.tiledmap(file.key, file.url, file.data, Tiled.Tilemap[file.format]);\n                break;\n\n            case 'physics':\n                this.physics(file.key, file.url, file.data, Phaser.Loader[file.format]);\n                break;\n\n            case 'bitmapFont':\n                this.bitmapFont(file.key, file.textureURL, file.xmlURL, file.xmlData, file.xSpacing, file.ySpacing);\n                break;\n\n            case 'atlasJSONArray':\n                this.atlasJSONArray(file.key, file.textureURL, file.atlasURL, file.atlasData);\n                break;\n\n            case 'atlasJSONHash':\n                this.atlasJSONHash(file.key, file.textureURL, file.atlasURL, file.atlasData);\n                break;\n\n            case 'atlasXML':\n                this.atlasXML(file.key, file.textureURL, file.atlasURL, file.atlasData);\n                break;\n\n            case 'atlas':\n                this.atlas(file.key, file.textureURL, file.atlasURL, file.atlasData, Phaser.Loader[file.format]);\n                break;\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-phaser-tiled/node_modules/phaser-tiled/src/physics.js":"module.exports = {\n    p2: {\n        /**\n        * Goes through all tiles in the given Tilemap and TilemapLayer and converts those set to collide into physics\n        * bodies. Only call this *after* you have specified all of the tiles you wish to collide with calls like\n        * Tilemap.setCollisionBetween, etc. Every time you call this method it will destroy any previously created\n        * bodies and remove them from the world. Therefore understand it's a very expensive operation and not to be\n        * done in a core game update loop.\n        *\n        * @method Phaser.Physics.P2#convertTilemap\n        * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.\n        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default\n        *       to map.currentLayer.\n        * @param {boolean} [addToWorld=true] - If true it will automatically add each body to the world, otherwise\n        *       it's up to you to do so.\n        * @param {boolean} [optimize=true] - If true adjacent colliding tiles will be combined into a single body\n        *       to save processing. However it means you cannot perform specific Tile to Body collision responses.\n        * @return {array} An array of the Phaser.Physics.P2.Body objects that were created.\n        */\n        // convertTiledmap: function (map, layer, addToWorld, optimize) {\n        //\n        //     if (typeof addToWorld === 'undefined') { addToWorld = true; }\n        //     if (typeof optimize === 'undefined') { optimize = true; }\n        //     if (typeof layer === 'undefined') { layer = map.currentLayer; }\n        //\n        //     layer = map.getTilelayer(layer);\n        //\n        //     if (!layer) {\n        //         return;\n        //     }\n        //\n        //     //  If the bodies array is already populated we need to nuke it\n        //     this.clearTilemapLayerBodies(map, layer.index);\n        //\n        //     var width = 0,\n        //         sx = 0,\n        //         sy = 0,\n        //         tile, body, right;\n        //\n        //     for (var y = 0, h = layer.size.y; y < h; y++)\n        //     {\n        //         width = 0;\n        //\n        //         for (var x = 0, w = layer.size.x; x < w; x++)\n        //         {\n        //             if (!layer.tiles[y]) {\n        //                 continue;\n        //             }\n        //\n        //             tile = layer.tiles[y][x];\n        //\n        //             if (tile && tile.collides)\n        //             {\n        //                 if (optimize)\n        //                 {\n        //                     right = map.getTileRight(layer.index, x, y);\n        //\n        //                     if (width === 0)\n        //                     {\n        //                         sx = tile.x;\n        //                         sy = tile.y;\n        //                         width = tile.width;\n        //                     }\n        //\n        //                     if (right && right.collides)\n        //                     {\n        //                         width += tile.width;\n        //                     }\n        //                     else\n        //                     {\n        //                         body = this.createBody(sx, sy, 0, false);\n        //\n        //                         body.addRectangle(width, tile.height, width / 2, tile.height / 2, 0);\n        //\n        //                         if (addToWorld)\n        //                         {\n        //                             this.addBody(body);\n        //                         }\n        //\n        //                         layer.bodies.push(body);\n        //\n        //                         width = 0;\n        //                     }\n        //                 }\n        //                 else\n        //                 {\n        //                     body = this.createBody(tile.x, tile.y, 0, false);\n        //\n        //                     body.clearShapes();\n        //                     body.addRectangle(tile.width, tile.height, tile.width / 2, tile.height / 2, tile.rotation);\n        //\n        //                     if (addToWorld)\n        //                     {\n        //                         this.addBody(body);\n        //                     }\n        //\n        //                     layer.bodies.push(body);\n        //                 }\n        //             }\n        //         }\n        //     }\n        //\n        //     return layer.bodies;\n        //\n        // },\n        /**\n        * Converts all of the polylines objects inside a Tiled ObjectGroup into physics bodies that are added to the world.\n        * Note that the polylines must be created in such a way that they can withstand polygon decomposition.\n        *\n        * @method Phaser.Physics.P2#convertCollisionObjects\n        * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.\n        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on, defaults to map.currentLayer.\n        * @param {boolean} [addToWorld=true] - If true it will automatically add each body to the world.\n        * @return {array} An array of the Phaser.Physics.Body objects that have been created.\n        */\n        convertTiledCollisionObjects: function (map, layer, addToWorld) {\n\n            if (typeof addToWorld === 'undefined') { addToWorld = true; }\n            if (typeof layer === 'undefined') { layer = map.currentLayer; }\n\n            layer = map.getObjectlayer(layer);\n\n            if (!layer) {\n                return;\n            }\n\n            for (var i = 0, len = layer.objects.length; i < len; i++)\n            {\n                var object = layer.objects[i];\n\n                var body = this.createBody(object.x, object.y, 0, false);\n\n                // polygon defined area\n                if (object.polygon || object.polyline) {\n                    if (!body.addPolygon(null, (object.polygon || object.polyline).map(mapPointToArray))) {\n                        console.warn('Unable to add poly collision body for object:', object);\n                        continue;\n                    }\n                }\n                // currently only circles are supported by P2, so we just use the width\n                else if (object.ellipse) {\n                    body.addCircle(object.width, object.width / 2, object.width / 2, object.rotation);\n                }\n                // no polygon, use rectangle defined by object itself\n                else {\n                    body.addRectangle(object.width, object.height, object.width / 2, object.height / 2, object.rotation);\n                }\n\n                if (!body.data.shapes[0]) {\n                    console.warn('No shape created for object:', object);\n                    continue;\n                }\n\n                body.data.shapes[0].sensor = !!(object.properties && object.properties.sensor);\n\n                if (object.properties && typeof object.properties.collisionResponse === 'boolean') {\n                    body.data.shapes[0].collisionResponse = object.properties.collisionResponse;\n                }\n\n                var bodyType = object.properties && object.properties.bodyType || 'static';\n\n                body[bodyType] = true;\n\n                body.tiledObject = object;\n\n                if (addToWorld) {\n                    this.addBody(body);\n                }\n\n                layer.bodies.push(body);\n            }\n        }\n    },\n\n    ninja: {\n        /**\n        * Goes through all tiles in the given Tilemap and TilemapLayer and converts those set to collide into physics\n        * bodies. Only call this *after* you have specified all of the tiles you wish to collide with calls like\n        * Tilemap.setCollisionBetween, etc. Every time you call this method it will destroy any previously created\n        * bodies and remove them from the world. Therefore understand it's a very expensive operation and not to be\n        * done in a core game update loop.\n        *\n        * In Ninja the Tiles have an ID from 0 to 33, where 0 is 'empty', 1 is a full tile, 2 is a 45-degree slope,\n        * etc. You can find the ID list either at the very bottom of `Tile.js`, or in a handy visual reference in the\n        * `resources/Ninja Physics Debug Tiles` folder in the repository. The slopeMap parameter is an array that controls\n        * how the indexes of the tiles in your tilemap data will map to the Ninja Tile IDs. For example if you had 6\n        * tiles in your tileset: Imagine the first 4 should be converted into fully solid Tiles and the other 2 are 45-degree\n        * slopes. Your slopeMap array would look like this: `[ 1, 1, 1, 1, 2, 3 ]`. Where each element of the array is\n        * a tile in your tilemap and the resulting Ninja Tile it should create.\n        *\n        * @method Phaser.Physics.Ninja#convertTilemap\n        * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.\n        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. Defaults to map.currentLayer.\n        * @param {object} [slopeMap] - The tilemap index to Tile ID map.\n        * @return {array} An array of the Phaser.Physics.Ninja.Tile objects that were created.\n        */\n        // convertTiledmap: function (map, layer, slopeMap) {\n        //\n        //     layer = map.getTilelayer(layer);\n        //\n        //     if (!layer) {\n        //         return;\n        //     }\n        //\n        //     //  If the bodies array is already populated we need to nuke it\n        //     this.clearTilemapLayerBodies(map, layer);\n        //\n        //     for (var y = 0, h = layer.size.y; y < h; y++)\n        //     {\n        //         if (!layer.tiles[y]) {\n        //             continue;\n        //         }\n        //\n        //         for (var x = 0, w = layer.size.x; x < w; x++)\n        //         {\n        //             var tile = layer.tiles[y][x],\n        //                 index = (y * layer.size.x) + x;\n        //\n        //             if (tile && slopeMap.hasOwnProperty(index))\n        //             {\n        //                 var body = new Phaser.Physics.Ninja.Body(\n        //                     this,\n        //                     null,\n        //                     3,\n        //                     slopeMap[index],\n        //                     0,\n        //                     tile.worldX + tile.centerX,\n        //                     tile.worldY + tile.centerY,\n        //                     tile.width,\n        //                     tile.height\n        //                 );\n        //\n        //                 layer.bodies.push(body);\n        //             }\n        //         }\n        //     }\n        //\n        //     return layer.bodies;\n        //\n        // }\n    }\n};\n\nfunction mapPointToArray(obj) {\n    return [obj.x, obj.y];\n}\n","/home/travis/build/npmtest/node-npmtest-phaser-tiled/node_modules/phaser-tiled/src/constants.js":"module.exports = {\n    /**\n     * @property CSV\n     * @type {Number}\n     * @static\n     * @final\n     */\n    CSV: 0,\n\n    /**\n     * @property CSV\n     * @type {Number}\n     * @static\n     * @final\n     */\n    TILED_JSON: 1,\n\n    /**\n     * @property CSV\n     * @type {Number}\n     * @static\n     * @final\n     */\n    TILED_XML: 2,\n\n    /**\n     * @property CSV\n     * @type {Number}\n     * @static\n     * @final\n     */\n    NORTH: 0,\n\n    /**\n     * @property CSV\n     * @type {Number}\n     * @static\n     * @final\n     */\n    EAST: 1,\n\n    /**\n     * @property CSV\n     * @type {Number}\n     * @static\n     * @final\n     */\n    SOUTH: 2,\n\n    /**\n     * @property CSV\n     * @type {Number}\n     * @static\n     * @final\n     */\n    WEST: 3\n};\n","/home/travis/build/npmtest/node-npmtest-phaser-tiled/node_modules/phaser-tiled/src/tiled/Objectlayer.js":"var utils = require('../utils');\n\n/**\n * Tiled object group is a special layer that contains entities\n *\n * @class Objectlayer\n * @extends Phaser.Group\n * @constructor\n * @param map {Tilemap} The tilemap instance that this belongs to\n * @param group {Object} All the settings for the layer\n */\nfunction Objectlayer(game, map, layer, index) {\n    Phaser.Group.call(this, game, map);\n\n    this.index = index;\n\n    // Non-Tiled related properties\n\n    /**\n     * The map instance this object group belongs to\n     *\n     * @property map\n     * @type Tilemap\n     */\n    this.map = map;\n\n    /**\n     * The const type of this object.\n     *\n     * @property type\n     * @type Number\n     * @default\n     */\n    this.type = Phaser.TILEMAPLAYER;\n\n    /**\n     * The name of the group\n     *\n     * @property name\n     * @type String\n     * @default ''\n     */\n    this.name = layer.name || '';\n\n    // Tiled related properties\n\n    /**\n     * The color of this group in the Tiled Editor,\n     *\n     * @property color\n     * @type\n     */\n    this.color = layer.color;\n\n    /**\n     * The user-defined properties of this group. Usually defined in the TiledEditor\n     *\n     * @property properties\n     * @type Object\n     */\n    this.properties = utils.parseTiledProperties(layer.properties);\n\n    /**\n     * The objects in this group that can be spawned\n     *\n     * @property objects\n     * @type Array\n     */\n    this.objects = layer.objects;\n\n    for (var i = 0; i < this.objects.length; ++i) {\n        utils.parseTiledProperties(this.objects[i].properties);\n    }\n\n    /**\n     * The Tiled type of tile layer, should always be 'objectgroup'\n     *\n     * @property layerType\n     * @type String\n     * @default 'objectgroup'\n     * @readOnly\n     */\n    this.layerType = layer.type || 'objectgroup';\n\n    // translate some tiled properties to our inherited properties\n    this.position.x = layer.x || 0;\n    this.position.y = layer.y || 0;\n    this.alpha = layer.opacity !== undefined ? layer.opacity : 1;\n    this.visible = layer.visible !== undefined ? layer.visible : true;\n\n    // physics bodies in this layer\n    this.bodies = [];\n\n    if (this.properties.batch) {\n        this.container = this.addChild(new Phaser.SpriteBatch(game));\n    }\n    else {\n        this.container = this;\n    }\n}\n\nObjectlayer.prototype = Object.create(Phaser.Group.prototype);\nObjectlayer.prototype.constructor = Objectlayer;\n\nmodule.exports = Objectlayer;\n\n/**\n * Spawns all the entities associated with this layer, and properly sets their attributes\n *\n * @chainable\n * @param [physicsBodyType=Phaser.Physics.ARCADE] {number} The physics system to create stuff on.\n * @param [spawnCallback] {function} A function to call for each object spawned.\n * @return {Objectlayer} Returns itself.\n */\nObjectlayer.prototype.spawn = function (physicsBodyType, spawnCallback) {\n    // we go through these backwards so that things that are higher in the\n    // list of object gets rendered on top.\n    for (var i = this.objects.length - 1; i >= 0; --i) {\n        var o = this.objects[i];\n        var props = o.properties;\n        var set;\n        // var interactive;\n        var obj;\n\n        props.tileprops = {};\n        props.animation = null;\n\n        var texture = props.texture;\n        // gid means a sprite from a tileset texture\n        if (o.gid) {\n            set = this.map.getTileset(o.gid);\n\n            // if the tileset exists\n            if (set) {\n                props.texture = set.getTileTexture(o.gid);\n                props.tileprops = set.getTileProperties(o.gid);\n                props.animation = set.getTileAnimations(o.gid);\n            }\n        }\n\n        o.name = o.name || props.name || props.tileprops.name || '';\n        o.type = o.type || props.type || props.tileprops.type || '';\n\n        // a manually specified string texture\n        if (typeof texture === 'string') {\n            props.texture = this.game.cache.getPixiTexture(texture);\n        }\n\n        if (typeof props.tileprops.texture === 'string') {\n            props.texture = this.game.cache.getPixiTexture(props.tileprops.texture);\n        }\n\n        // when props.texture is empty it will just create an empty sprite.\n        obj = this.game.add.sprite(o.x, o.y, props.texture, null, this.container);\n\n        // setup the properties of the sprite\n        obj.name = o.name;\n        obj.rotation = o.rotation;\n        obj.objectType = o.type;\n\n        if (!props.texture) {\n            obj.width = o.width;\n            obj.height = o.height;\n        }\n\n        var blendMode = props.blendMode || this.properties.blendMode;\n        obj.blendMode = blendMode ? Phaser.blendModes[blendMode] : Phaser.blendModes.NORMAL;\n\n        // create physics if this body is physical.\n        if (props.collides || props.tileprops.collides) {\n            this.game.physics.enable(obj, physicsBodyType, props.debug || props.tileprops.debug);\n\n            obj.body.setRectangle(obj.width, obj.height, obj.width / 2, -obj.height / 2, obj.rotation);\n\n            obj.body[props.bodyType || props.tileprops.bodyType || 'static'] = true;\n\n            if (props.sensor) {\n                obj.body.data.shapes[0].sensor = true;\n            }\n        }\n\n        var a = props.anchor || props.tileprops.anchor;\n        obj.anchor.x = a ? a[0] : 0;\n        obj.anchor.y = a ? a[1] : 1;\n\n        if (props.tileprops.flippedX) {\n            obj.scale.x = -1;\n            obj.position.x += Math.abs(obj.width);\n        }\n\n        if (props.tileprops.flippedY) {\n            obj.scale.y = -1;\n            obj.position.y += Math.abs(obj.height);\n        }\n\n        // from Tiled Editor:\n        // https://github.com/bjorn/tiled/blob/b059a13b2864ea029fb741a90780d31cf5b67043/src/libtiled/maprenderer.cpp#L135-L145\n        if (props.tileprops.flippedAD) {\n            obj.rotation = this.game.math.degToRad(90);\n            obj.scale.x *= -1;\n\n            var sx = obj.scale.x;\n            obj.scale.x = obj.scale.y;\n            obj.scale.y = sx;\n\n            var halfDiff = Math.abs(o.height / 2) - Math.abs(o.width / 2);\n            obj.position.y += halfDiff;\n            obj.position.x += halfDiff;\n        }\n\n        if (props.animation && obj.animations) {\n            obj.animations.copyFrameData(props.animation.data, 0);\n            obj.animations.add('tile', null, props.animation.rate, true).play();\n            // obj.animations.play(props.animation || props.tileprops.animation);\n        }\n\n        if (typeof o.rotation === 'number') {\n            obj.rotation = o.rotation;\n        }\n\n        // visible was recently added to Tiled, default old versions to true\n        obj.visible = o.visible !== undefined ? !!o.visible : true;\n\n        // if (this.map.orientation === 'isometric') {\n        //     var toTileX = o.x / this.map.tileWidth,\n        //         toTileY = o.y / this.map.tileWidth;\n\n        //     //This cannot be the simplest form of this...\n        //     o.x = (toTileX * this.map.tileWidth) - ((toTileY - 1) * (this.map.tileWidth / 2));\n        //     o.y = (toTileY * this.map.tileWidth / 2) + (toTileX * this.map.tileWidth);\n        // }\n\n        // interactive = this._getInteractive(set, props);\n\n        // //pass through all events\n        // if (interactive) {\n        //     obj.interactive = interactive;\n\n        //     obj.click = this.onObjectEvent.bind(this, 'click', obj);\n        //     obj.mousedown = this.onObjectEvent.bind(this, 'mousedown', obj);\n        //     obj.mouseup = this.onObjectEvent.bind(this, 'mouseup', obj);\n        //     obj.mousemove = this.onObjectEvent.bind(this, 'mousemove', obj);\n        //     obj.mouseout = this.onObjectEvent.bind(this, 'mouseout', obj);\n        //     obj.mouseover = this.onObjectEvent.bind(this, 'mouseover', obj);\n        //     obj.mouseupoutside = this.onObjectEvent.bind(this, 'mouseupoutside', obj);\n        // }\n\n        // set custom properties\n        obj.properties = {};\n        for (var t in props.tileprops) {\n            obj.properties[t] = props.tileprops[t];\n        }\n\n        for (var k in props) {\n            if (k !== 'tileprops') {\n                obj.properties[k] = props[k];\n            }\n        }\n\n        obj._objIndex = i;\n\n        if (spawnCallback) {\n            spawnCallback(obj);\n        }\n    }\n\n    return this;\n};\n\nObjectlayer.prototype.getObject = function (name) {\n    for (var i = 0; i < this.objects.length; ++i) {\n        if (this.objects[i].name === name) {\n            return this.objects[i];\n        }\n    }\n};\n\n/**\n * Called internally whenever an event happens on an object, used to echo to the map.\n *\n * @method onObjectEvent\n * @param eventName {String} The name of the event\n * @param obj {Container|Sprite} The object the event happened to\n * @param data {mixed} The event data that was passed along\n * @private\n */\nObjectlayer.prototype.onObjectEvent = function (eventName, obj, data) {\n    this.map.onObjectEvent(eventName, obj, data);\n};\n\n/**\n * Creates a polygon from the vertices in a polygon Tiled property\n *\n * @method _getPolygon\n * @param obj {Object} The polygon Tiled object\n * @return {Polygon} The polygon created\n * @private\n */\nObjectlayer.prototype._getPolygon = function (o) {\n    var points = [];\n    for (var i = 0, il = o.polygon.length; i < il; ++i) {\n        points.push(new Phaser.Point(o.polygon[i].x, o.polygon[i].y));\n    }\n\n    return new Phaser.Polygon(points);\n};\n\n/**\n * Creates a polyline from the vertices in a polyline Tiled property\n *\n * @method _getPolyline\n * @param obj {Object} The polyline Tiled object\n * @return {Polygon} The polyline created\n * @private\n */\nObjectlayer.prototype._getPolyline = function (o) {\n    var points = [];\n    for (var i = 0, il = o.polyline.length; i < il; ++i) {\n        points.push(new Phaser.Point(o.polyline[i].x, o.polyline[i].y));\n    }\n\n    return new Phaser.Polygon(points);\n};\n\n/**\n * Creates a ellipse from the vertices in a ellipse Tiled property\n *\n * @method _getEllipse\n * @param obj {Object} The ellipse Tiled object\n * @return {Ellipse} The ellipse created\n * @private\n */\nObjectlayer.prototype._getEllipse = function (o) {\n    return new Phaser.Ellipse(0, 0, o.width, o.height);\n};\n\n/**\n * Creates a rectangle from the vertices in a rectangle Tiled property\n *\n * @method _getRectangle\n * @param obj {Object} The rectangle Tiled object\n * @return {Rectangle} The rectangle created\n * @private\n */\nObjectlayer.prototype._getRectangle = function (o) {\n    return new Phaser.Rectangle(0, 0, o.width, o.height);\n};\n\n/**\n * Checks if an object should be marked as interactive\n *\n * @method _getInteractive\n * @param set {Tileset} The tileset for the object\n * @param props {Object} The Tiled properties object\n * @return {Boolean} Whether or not the item is interactive\n * @private\n */\nObjectlayer.prototype._getInteractive = function (set, props) {\n    // TODO: This is wrong, if 'false' is set on a lower level a higher level will override\n    // first check the lowest level value (on the tile iteself)\n    return props.interactive || // obj interactive\n            props.tileprops.interactive || // tile object interactive\n            (set && set.properties.interactive) || // tileset interactive\n            this.properties.interactive || // layer interactive\n            this.map.properties.interactive; // map interactive\n};\n\n/**\n * Despawns all the sprites associated with this layer\n *\n * @method despawn\n * @param destroy {Boolean} Should we destroy the children as well?\n * @return {Objectlayer} Returns itself.\n * @chainable\n */\nObjectlayer.prototype.despawn = function (destroy) {\n    return Phaser.Group.prototype.removeAll.call(this, destroy);\n};\n\n/**\n * Destroys the group completely\n *\n * @method destroy\n */\nObjectlayer.prototype.destroy = function () {\n    Phaser.Group.prototype.destroy.apply(this, arguments);\n\n    // destroy bodies\n    for (var i = 0; i < this.bodies.length; ++i) {\n        this.bodies[i].destroy();\n    }\n\n    this.bodies = null;\n\n    this.map = null;\n    this.properties = null;\n    this.objects = null;\n};\n","/home/travis/build/npmtest/node-npmtest-phaser-tiled/node_modules/phaser-tiled/src/tiled/Tile.js":"/**\n * Base Tile implementation, a tile is a single tile in a tilemap layer\n *\n * @class Tile\n * @extends Phaser.Sprite\n * @constructor\n */\nfunction Tile(game, x, y, tileId, tileset, layer) {\n    Phaser.Sprite.call(this,\n        game,\n        (x * tileset.tileWidth) + tileset.tileoffset.x,\n        (y * tileset.tileHeight) + tileset.tileoffset.y,\n        tileset.getTileTexture(tileId)\n    );\n\n    this.type = Phaser.TILESPRITE;\n\n    /**\n    * @property {object} layer - The layer in the Tilemap data that this tile belongs to.\n    */\n    this.layer = layer;\n\n    /**\n    * @property {object} tileset - The tileset that this tile's texture is from.\n    */\n    this.tileset = tileset;\n\n    /**\n    * @property {Phaser.Point} tilePosition - The position of the tile in 'tile coords'\n    */\n    this.tilePosition = new Phaser.Point(x, y);\n\n    /**\n    * @property {number} centerX - The center of the tile.\n    */\n    this.centerX = Math.abs(tileset.tileWidth / 2);\n\n    /**\n    * @property {number} centerY - The height of the tile in pixels.\n    */\n    this.centerY = Math.abs(tileset.tileHeight / 2);\n\n    /**\n    * @property {object} properties - Tile specific properties.\n    */\n    this.properties = tileset.getTileProperties(tileId);\n\n    /**\n    * @property {boolean} scanned - Has this tile been walked / turned into a poly?\n    */\n    this.scanned = false;\n\n    /**\n    * @property {boolean} faceTop - Is the top of this tile an interesting edge?\n    */\n    this.faceTop = false;\n\n    /**\n    * @property {boolean} faceBottom - Is the bottom of this tile an interesting edge?\n    */\n    this.faceBottom = false;\n\n    /**\n    * @property {boolean} faceLeft - Is the left of this tile an interesting edge?\n    */\n    this.faceLeft = false;\n\n    /**\n    * @property {boolean} faceRight - Is the right of this tile an interesting edge?\n    */\n    this.faceRight = false;\n\n    /**\n    * @property {boolean} collideLeft - Indicating collide with any object on the left.\n    * @default\n    */\n    this.collideLeft = this.properties.collideLeft !== undefined ?\n        this.properties.collideLeft : (this.properties.collides || false);\n\n    /**\n    * @property {boolean} collideRight - Indicating collide with any object on the right.\n    * @default\n    */\n    this.collideRight = this.properties.collideRight !== undefined ?\n        this.properties.collideRight : (this.properties.collides || false);\n\n    /**\n    * @property {boolean} collideUp - Indicating collide with any object on the top.\n    * @default\n    */\n    this.collideUp = this.properties.collideUp !== undefined ?\n        this.properties.collideUp : (this.properties.collides || false);\n\n    /**\n    * @property {boolean} collideDown - Indicating collide with any object on the bottom.\n    * @default\n    */\n    this.collideDown = this.properties.collideDown !== undefined ?\n        this.properties.collideDown : (this.properties.collides || false);\n\n    /**\n    * @property {function} collisionCallback - Tile collision callback.\n    * @default\n    */\n    this.collisionCallback = null;\n\n    /**\n    * @property {object} collisionCallbackContext - The context in which the collision callback will be called.\n    * @default\n    */\n    this.collisionCallbackContext = this;\n\n    // load animation data\n    var animData = tileset.getTileAnimations(tileId);\n    if (animData) {\n        this.animations.copyFrameData(animData.data, 0);\n        this.animations.add('tile', null, animData.rate, true).play();\n    }\n\n    // set the blend mode\n    var blendMode = this.properties.blendMode || layer.properties.blendMode;\n    this.blendMode = blendMode ? Phaser.blendModes[blendMode] : Phaser.blendModes.NORMAL;\n\n    // setup the flipped states\n    if (this.properties.flippedX) {\n        this.scale.x = -1;\n        this.position.x += tileset.tileWidth;\n    }\n\n    if (this.properties.flippedY) {\n        this.scale.y = -1;\n        this.position.y += tileset.tileHeight;\n    }\n\n    // from Tiled Editor:\n    // https://github.com/bjorn/tiled/blob/b059a13b2864ea029fb741a90780d31cf5b67043/src/libtiled/maprenderer.cpp#L135-L145\n    if (this.properties.flippedAD) {\n        this.rotation = this.game.math.degToRad(90);\n        this.scale.x *= -1;\n\n        var sx = this.scale.x;\n        this.scale.x = this.scale.y;\n        this.scale.y = sx;\n\n        var halfDiff = Math.abs(this.height / 2) - Math.abs(this.width / 2);\n        this.position.y += halfDiff;\n        this.position.x += halfDiff;\n    }\n}\n\nTile.prototype = Object.create(Phaser.Sprite.prototype);\nTile.prototype.constructor = Tile;\n\nmodule.exports = Tile;\n\n/**\n* Check if the given x and y world coordinates are within this Tile.\n*\n* @method Phaser.Tile#containsPoint\n* @param {number} x - The x coordinate to test.\n* @param {number} y - The y coordinate to test.\n* @return {boolean} True if the coordinates are within this Tile, otherwise false.\n*/\nTile.prototype.containsPoint = function (x, y) {\n\n    return !(x < this.worldX || y < this.worldY || x > this.right || y > this.bottom);\n\n};\n\n/**\n* Check for intersection with this tile.\n*\n* @method Phaser.Tile#intersects\n* @param {number} x - The x axis in pixels.\n* @param {number} y - The y axis in pixels.\n* @param {number} right - The right point.\n* @param {number} bottom - The bottom point.\n* @return {boolean} True if the coordinates are within this Tile, otherwise false.\n*/\nTile.prototype.intersects = function (x, y, right, bottom) {\n\n    if (right <= this.worldX)\n    {\n        return false;\n    }\n\n    if (bottom <= this.worldY)\n    {\n        return false;\n    }\n\n    if (x >= this.worldX + this.width)\n    {\n        return false;\n    }\n\n    if (y >= this.worldY + this.height)\n    {\n        return false;\n    }\n\n    return true;\n\n};\n\n/**\n* Set a callback to be called when this tile is hit by an object.\n* The callback must true true for collision processing to take place.\n*\n* @method Phaser.Tile#setCollisionCallback\n* @param {function} callback - Callback function.\n* @param {object} context - Callback will be called within this context.\n*/\nTile.prototype.setCollisionCallback = function (callback, context) {\n\n    this.collisionCallback = callback;\n    this.collisionCallbackContext = context;\n\n};\n\n/**\n* Clean up memory.\n*\n* @method Phaser.Tile#destroy\n*/\nTile.prototype.destroy = function () {\n    Phaser.Sprite.prototype.destroy.apply(this, arguments);\n\n    this.layer = null;\n    this.tileset = null;\n    this.tilePosition = null;\n\n    this.properties = null;\n\n    this.collisionCallback = null;\n\n    this.collisionCallbackContext = null;\n};\n\n/**\n* Sets the collision flags for each side of this tile and updates the interesting faces list.\n*\n* @method Phaser.Tile#setCollision\n* @param {boolean} left - Indicating collide with any object on the left.\n* @param {boolean} right - Indicating collide with any object on the right.\n* @param {boolean} up - Indicating collide with any object on the top.\n* @param {boolean} down - Indicating collide with any object on the bottom.\n*/\nTile.prototype.setCollision = function (left, right, up, down) {\n\n    this.collideLeft = left;\n    this.collideRight = right;\n    this.collideUp = up;\n    this.collideDown = down;\n\n    this.faceLeft = left;\n    this.faceRight = right;\n    this.faceTop = up;\n    this.faceBottom = down;\n\n};\n\n/**\n* Reset collision status flags.\n*\n* @method Phaser.Tile#resetCollision\n*/\nTile.prototype.resetCollision = function () {\n\n    this.collideLeft = false;\n    this.collideRight = false;\n    this.collideUp = false;\n    this.collideDown = false;\n\n    this.faceLeft = false;\n    this.faceRight = false;\n    this.faceTop = false;\n    this.faceBottom = false;\n\n};\n\n/**\n* Is this tile interesting?\n*\n* @method Phaser.Tile#isInteresting\n* @param {boolean} collides - If true will check any collides value.\n* @param {boolean} faces - If true will check any face value.\n* @return {boolean} True if the Tile is interesting, otherwise false.\n*/\nTile.prototype.isInteresting = function (collides, faces) {\n\n    if (collides && faces)\n    {\n        //  Does this tile have any collide flags OR interesting face?\n        return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown ||\n            this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback);\n    }\n    else if (collides)\n    {\n        //  Does this tile collide?\n        return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown);\n    }\n    else if (faces)\n    {\n        //  Does this tile have an interesting face?\n        return (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight);\n    }\n\n    return false;\n\n};\n\n/**\n* Copies the tile data and properties from the given tile to this tile.\n*\n* @method Phaser.Tile#copy\n* @param {Phaser.Tile} tile - The tile to copy from.\n*/\nTile.prototype.copy = function (tile) {\n\n    this.index = tile.index;\n    this.alpha = tile.alpha;\n    this.properties = tile.properties;\n\n    this.collideUp = tile.collideUp;\n    this.collideDown = tile.collideDown;\n    this.collideLeft = tile.collideLeft;\n    this.collideRight = tile.collideRight;\n\n    this.collisionCallback = tile.collisionCallback;\n    this.collisionCallbackContext = tile.collisionCallbackContext;\n\n};\n\nObject.defineProperty(Tile.prototype, 'worldX', {\n    get: function () {\n        return this.position.x;\n    },\n    set: function (val) {\n        this.position.x = val;\n    }\n});\n\nObject.defineProperty(Tile.prototype, 'worldY', {\n    get: function () {\n        return this.position.y;\n    },\n    set: function (val) {\n        this.position.y = val;\n    }\n});\n\n/**\n* @name Phaser.Tile#collides\n* @property {boolean} collides - True if this tile can collide on any of its faces.\n* @readonly\n*/\nObject.defineProperty(Tile.prototype, 'collides', {\n\n    get: function () {\n        return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown);\n    }\n\n});\n\n/**\n* @name Phaser.Tile#canCollide\n* @property {boolean} canCollide - True if this tile can collide on any of its faces or has a collision callback set.\n* @readonly\n*/\nObject.defineProperty(Tile.prototype, 'canCollide', {\n\n    get: function () {\n        return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback);\n    }\n\n});\n\n/**\n* @name Phaser.Tile#left\n* @property {number} left - The x value in pixels.\n* @readonly\n*/\nObject.defineProperty(Tile.prototype, 'left', {\n\n    get: function () {\n        return this.worldX;\n    }\n\n});\n\n/**\n* @name Phaser.Tile#right\n* @property {number} right - The sum of the x and width properties.\n* @readonly\n*/\nObject.defineProperty(Tile.prototype, 'right', {\n\n    get: function () {\n        return this.worldX + this.width;\n    }\n\n});\n\n/**\n* @name Phaser.Tile#top\n* @property {number} top - The y value.\n* @readonly\n*/\nObject.defineProperty(Tile.prototype, 'top', {\n\n    get: function () {\n        return this.worldY;\n    }\n\n});\n\n/**\n* @name Phaser.Tile#bottom\n* @property {number} bottom - The sum of the y and height properties.\n* @readonly\n*/\nObject.defineProperty(Tile.prototype, 'bottom', {\n\n    get: function () {\n        return this.worldY + this.height;\n    }\n\n});\n","/home/travis/build/npmtest/node-npmtest-phaser-tiled/node_modules/phaser-tiled/src/tiled/Tilelayer.js":"var utils = require('../utils');\n\n/**\n * The Tilelayer is the visual tiled layer that actually displays on the screen\n *\n * This class will be created by the Tilemap.\n *\n * @class Tilelayer\n * @extends Group\n * @constructor\n * @param game {Phaser.Game} The game instance this belongs to\n * @param map {Tilemap} The tilemap instance that this belongs to\n * @param index {Number} The index of the layer in the tilemap\n * @param width {Number} The width of the renderable area of the layer\n * @param height {Number} The height of the renderable area of the layer\n */\n//\n// TODO: Add chunk prerendering?\n//\n// for discussions about this implementation:\n//   see: https://github.com/GoodBoyDigital/pixi.js/issues/48\n//   and: https://github.com/photonstorm/phaser/issues/1145\nfunction Tilelayer(game, map, layer, index) {\n    Phaser.Group.call(this, game, map);\n\n    this.index = index;\n\n    // Non-Tiled related properties\n\n    /**\n     * The map instance this tilelayer belongs to\n     *\n     * @property map\n     * @type Tilemap\n     */\n    this.map = map;\n\n    /**\n     * The const type of this object.\n     *\n     * @property type\n     * @type Number\n     * @default\n     */\n    this.type = Phaser.TILEMAPLAYER;\n\n    /**\n    * An object that is fixed to the camera ignores the position of any ancestors in the display list\n    * and uses its x/y coordinates as offsets from the top left of the camera.\n    *\n    * @property {boolean} fixedToCamera - Fixes this object to the Camera.\n    * @default\n    */\n    this.fixedToCamera = false;\n\n    /**\n    * @property {Phaser.Point} cameraOffset - If this object is fixed to the camera then use this Point\n    * to specify how far away from the Camera x/y it's rendered.\n    */\n    this.cameraOffset = new Phaser.Point(0, 0);\n\n    /**\n     * All the tiles this layer has\n     *\n     * @property tiles\n     * @type Object\n     */\n    this.tiles = {};\n\n    /**\n     * The scroll speed of the layer relative to the camera\n     * (e.g. a scrollFactor of 0.5 scrolls half as quickly as the\n     * 'normal' layers do)\n     *\n     * @property scroll\n     * @type Phaser.Point\n     * @default new Phaser.Point(1, 1)\n     */\n    // TODO: This doesn't actually work yet!\n    this.scrollFactor = new Phaser.Point(1, 1);\n\n    // Tiled related properties\n\n    /**\n     * The name of the layer\n     *\n     * @property name\n     * @type String\n     * @default ''\n     */\n    this.name = layer.name || '';\n\n    /**\n     * The size of the layer\n     *\n     * @property size\n     * @type Phaser.Point\n     * @default new Phaser.Point(1, 1)\n     */\n    this.size = new Phaser.Point(layer.width || 0, layer.height || 0);\n\n    /**\n     * The tile IDs of the tilemap\n     *\n     * @property tileIds\n     * @type Uint32Array|Array\n     */\n    this.tileIds = Phaser.devicetypedArray ? new Uint32Array(layer.data) : layer.data;\n\n    /**\n     * The user-defined properties of this group. Usually defined in the TiledEditor\n     *\n     * @property properties\n     * @type Object\n     */\n    this.properties = utils.parseTiledProperties(layer.properties);\n\n    /**\n     * The Tiled type of tile layer, should always be 'tilelayer'\n     *\n     * @property layerType\n     * @type String\n     * @default 'tilelayer'\n     * @readOnly\n     */\n    this.layerType = layer.type || 'tilelayer';\n\n    /**\n    * @property {number} rayStepRate - When ray-casting against tiles this is the number of steps it will jump.\n    * For larger tile sizes you can increase this to improve performance.\n    * @default\n    */\n    this.rayStepRate = 4;\n\n    // translate some tiled properties to our inherited properties\n    this.x = layer.x || 0;\n    this.y = layer.y || 0;\n    this.alpha = layer.opacity !== undefined ? layer.opacity : 1;\n    this.visible = layer.visible !== undefined ? layer.visible : true;\n\n    // physics bodies in this layer\n    this.bodies = [];\n\n    // some private trackers\n    this._buffered = { left: false, right: false, top: false, bottom: false };\n    this._scroll = new Phaser.Point(); // the current scroll position\n    this._scrollDelta = new Phaser.Point(); // the current delta of scroll since the last sprite move\n    this._renderArea = new Phaser.Rectangle(); // the area to render in tiles\n\n    /**\n    * @property {object} _mc - Local map data and calculation cache.\n    * @private\n    */\n    this._mc = {\n        cw: map.tileWidth,\n        ch: map.tileHeight,\n        tx: 0,\n        ty: 0,\n        tw: 0,\n        th: 0\n    };\n\n    // should we clear and rerender all the tiles\n    this.dirty = true;\n\n    // if batch is true, store children in a spritebatch\n    if (this.properties.batch) {\n        this.container = this.addChild(new Phaser.SpriteBatch(game));\n    }\n    else {\n        this.container = this;\n    }\n\n    for (var i = 0; i < this.tileIds.length; ++i) {\n        var x = i % this.size.x;\n        var y = (i - x) / this.size.x;\n\n        if (!this.tiles[y]) {\n            this.tiles[y] = {};\n        }\n\n        this.tiles[y][x] = null;\n    }\n\n    this._tilePool = [];\n    this._animTexturePool = [];\n}\n\nTilelayer.prototype = Object.create(Phaser.Group.prototype);\nTilelayer.prototype.constructor = Tilelayer;\n\nmodule.exports = Tilelayer;\n\nTilelayer.prototype.setupRenderArea = function () {\n    // calculate the X/Y start of the render area as the tile location of the top-left of the camera view.\n    this._renderArea.x = this.game.math.clampBottom(this.game.math.floorTo(this._scroll.x / this.map.scaledTileWidth), 0);\n    this._renderArea.y = this.game.math.clampBottom(this.game.math.floorTo(this._scroll.y / this.map.scaledTileHeight), 0);\n\n    // the width of the render area is the camera view width in tiles\n    this._renderArea.width = this.game.math.ceilTo(this.game.camera.view.width / this.map.scaledTileWidth);\n\n    // ensure we don't go outside the map width\n    this._renderArea.width = (this._renderArea.x + this._renderArea.width > this.map.size.x) ?\n        (this.map.size.x - this._renderArea.x) : this._renderArea.width;\n\n    // the height of the render area is the camera view height in tiles\n    this._renderArea.height = this.game.math.ceilTo(this.game.camera.view.height / this.map.scaledTileHeight);\n\n    // ensure we don't go outside the map height\n    this._renderArea.height = (this._renderArea.y + this._renderArea.height > this.map.size.y) ?\n        (this.map.size.y - this._renderArea.y) : this._renderArea.height;\n};\n\n/**\n * Sets the world size to match the size of this layer.\n *\n * @method resizeWorld\n */\nTilelayer.prototype.resizeWorld = function () {\n    this.game.world.setBounds(0, 0, this.widthInPixels, this.heightInPixels);\n\n    var physics = this.game.physics;\n\n    if (physics.arcade) {\n        physics.arcade.setBoundsToWorld();\n    }\n\n    if (physics.ninja) {\n        physics.ninja.setBoundsToWorld();\n    }\n\n    if (physics.p2) {\n        physics.p2.setBoundsToWorld(true, true, false, true, false);\n    }\n};\n\n/**\n * Automatically called by Tilemap.postUpdate. Handles scrolling the layer and updating the scale\n *\n * @method postUpdate\n */\nTilelayer.prototype.postUpdate = function () {\n    Phaser.Group.prototype.postUpdate.call(this);\n\n    if (this.fixedToCamera) {\n        this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;\n        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;\n    }\n\n    // TODO: this seems to not work properly when scale changes on the fly. Look into that...\n    if (this.dirty || this.map.dirty) {\n        // no longer dirty\n        this.dirty = false;\n\n        // setup the render area, and scaled tilesize\n        this.setupRenderArea();\n\n        // resize the world to the new size\n        // TODO: Seems dangerous to do this here, may break if user wants to manually set bounds\n        // and this reset it each time scale changes.\n        this.resizeWorld();\n\n        // render the tiles on the screen\n        this.setupTiles();\n\n        return this;\n    }\n\n    this.scrollX = this.game.camera.x;\n    this.scrollY = this.game.camera.y;\n\n    this.updatePan();\n};\n\n/**\n * Clears the current tiles and sets up the render area\n *\n * @method setupTiles\n * @private\n */\nTilelayer.prototype.setupTiles = function () {\n    // clear all the tiles\n    this.clearTiles();\n\n    var area = (this._renderArea.width + 2) * (this._renderArea.height + 2);\n\n    // prealloc the pool with the necessary objects\n    while (this._tilePool.length < area) {\n        this._tilePool.push(this._createTile());\n    }\n\n    // dealloc objects that we no longer need\n    while (this._tilePool.length > area) {\n        this._tilePool.pop().destroy();\n    }\n\n    // reset buffered status\n    this._buffered.left = this._buffered.right = this._buffered.top = this._buffered.bottom = false;\n\n    // reset scroll delta\n    this._scrollDelta.x = this._scroll.x % this.map.scaledTileWidth;\n    this._scrollDelta.y = this._scroll.y % this.map.scaledTileHeight;\n\n    // setup the current viewport\n    // setup a tile for each location in the renderArea\n    for (var x = this._renderArea.x; x < this._renderArea.right; ++x) {\n        for (var y = this._renderArea.y; y < this._renderArea.bottom; ++y) {\n            this.moveTileSprite(-1, -1, x, y);\n        }\n    }\n\n    this.sortTiles();\n};\n\n/**\n * Sorts the tiles based on their sort order (which will be set according to the map's renderorder) if\n * the map's obeyRenderorder is set to true\n *\n * @method sortTiles\n */\nTilelayer.prototype.sortTiles = function () {\n    if (this.map.obeyRenderorder) {\n        this.sort('sortOrder', Phaser.Group.SORT_ASCENDING);\n    }\n};\n\n/**\n * Clears all the tiles currently used to render the layer\n *\n * @method clearTiles\n * @return {Tilelayer} Returns itself.\n * @chainable\n */\nTilelayer.prototype.clearTiles = function () {\n    for (var c = this.container.children.length - 1; c > -1; --c) {\n        if (this.container.children[c].type === Phaser.TILESPRITE) {\n            this.clearTile(this.container.children[c]);\n        }\n    }\n\n    return this;\n};\n\nTilelayer.prototype.clearTile = function (tile) {\n    // this was playing an animation, put its texture back into the animation texture pool\n    if (tile.animations._anims.tile && tile.animations._anims.tile.isPlaying) {\n        this._animTexturePool.push(tile.texture);\n    }\n\n    tile.sortOrder = 0;\n    tile.visible = false;\n    tile.animations.stop();\n    this._tilePool.push(tile);\n};\n\nTilelayer.prototype._freeTile = function (x, y) {\n    if (this.tiles[y] && this.tiles[y][x]) {\n        this.clearTile(this.tiles[y][x]);\n        this.tiles[y][x] = null;\n    }\n};\n\nTilelayer.prototype._createTile = function () {\n    var s = new Phaser.Sprite(this.game);\n\n    s.type = Phaser.TILESPRITE;\n    s.sortOrder = 0;\n\n    this.container.addChild(s);\n\n    return s;\n};\n\nTilelayer.prototype._resetTile = function (tile, x, y, tileId, tileset) {\n    // calculate some values for the tile\n    var texture = tileset.getTileTexture(tileId);\n    var props = tileset.getTileProperties(tileId);\n    var animData = tileset.getTileAnimations(tileId);\n    var blendMode = props.blendMode || this.properties.blendMode;\n\n    tile.reset(x, y);\n\n    tile.setTexture(texture);\n\n    tile.blendMode = blendMode ? Phaser.blendModes[blendMode] : Phaser.blendModes.NORMAL;\n\n    // add animations if there are any\n    if (animData) {\n        tile.animations.loadFrameData(animData.data);\n\n        // use a tile animation texture, each animated tile *must* be using\n        // a separate texture or they will share one and mess with eachother's\n        // animations. Phaser updates a sprite's texture frame as animations play out\n        // so a shared texture means each sprite's update effects other sprites besides itself.\n        var animTexture = this._animTexturePool.pop() || new PIXI.Texture(texture.baseTexture, texture.frame);\n\n        animTexture.baseTexture = texture.baseTexture;\n        animTexture.frame.copyFrom(texture.frame);\n        animTexture.setFrame(animTexture.frame);\n\n        tile.setTexture(animTexture);\n\n        if (!tile.animations._anims.tile) {\n            tile.animations.add('tile');\n        }\n\n        tile.animations.play('tile', animData.rate, true);\n    }\n\n    // Flipped states based on TiledEditor source:\n    // https://github.com/bjorn/tiled/blob/0ae2b91d31dfc5caf35cb4f116d71cec73a5ac7d/src/libtiled/maprenderer.cpp#L134-L154\n\n    // setup the flipped states\n    if (props.flippedX) {\n        tile.scale.x = -1;\n        tile.position.x += tileset.tileWidth;\n    }\n    else {\n        tile.scale.x = 1;\n    }\n\n    if (props.flippedY) {\n        tile.scale.y = -1;\n        tile.position.y += tileset.tileHeight;\n    }\n    else {\n        tile.scale.y = 1;\n    }\n\n    if (props.flippedAD) {\n        tile.rotation = 1.5707963267948966; // this.game.math.degToRad(90);\n        tile.scale.x *= -1;\n\n        var sx = tile.scale.x;\n        tile.scale.x = tile.scale.y;\n        tile.scale.y = sx;\n\n        var halfDiff = Math.abs(tile.height / 2) - Math.abs(tile.width / 2);\n        tile.position.y += halfDiff;\n        tile.position.x += halfDiff;\n    }\n    else {\n        tile.rotation = 0;\n    }\n\n};\n\n/**\n * Moves a tile sprite from one position to another, and creates a new tile\n * if the old position didn't have a sprite\n *\n * @method moveTileSprite\n * @param fromTileX {Number} The x coord of the tile in units of tiles (not pixels) to move from\n * @param fromTileY {Number} The y coord of the tile in units of tiles (not pixels) to move from\n * @param toTileX {Number} The x coord of the tile in units of tiles (not pixels) to move to\n * @param toTileY {Number} The y coord of the tile in units of tiles (not pixels) to move to\n * @return {Tile} The sprite to display\n */\nTilelayer.prototype.moveTileSprite = function (fromTileX, fromTileY, toTileX, toTileY) {\n    // free the tiles we are dealing with\n    this._freeTile(toTileX, toTileY);\n    this._freeTile(fromTileX, fromTileY);\n\n    // if off the map, just ignore it\n    if (toTileX < 0 || toTileY < 0 || toTileX >= this.map.size.x || toTileY >= this.map.size.y) {\n        return null;\n    }\n\n    var tile;\n    var id = (toTileX + (toTileY * this.size.x));\n    var tileId = this.tileIds[id];\n    var tileset = this.map.getTileset(tileId);\n\n    // if no tileset, return\n    if (!tileset) {\n        return null;\n    }\n\n    // grab a new tile from the pool\n    // should exist since we just freed earlier, and the pool is hydrated\n    // with enough tiles for the viewport\n    tile = this._tilePool.pop();\n\n    // if we couldn't find a tile from the pool, then explode.\n    if (!tile) {\n        throw new Error(\n            '[phaser-tiled] Unable to find a tile in the pool, this shouldn\\'t be possible! ' +\n            'Please report this issue at (https://github.com/englercj/phaser-tiled/issues), ' +\n            'and include a running example.'\n        );\n    }\n\n    this._resetTile(\n        tile,\n        (toTileX * this.map.tileWidth) + tileset.tileoffset.x,\n        (toTileY * this.map.tileHeight) + tileset.tileoffset.y,\n        tileId,\n        tileset\n    );\n\n    // sort order of tile, could/should be in _resetTile but it would need the map coordinates\n    if (this.map.obeyRenderorder) {\n        if (this.map.orientation === 'orthogonal') {\n            if (this.map.renderorder === 'right-up') {\n                tile.sortOrder = toTileX - this.map.size.x * toTileY;\n            }\n            else if (this.map.renderorder === 'right-down') {\n                tile.sortOrder = toTileX + this.map.size.x * toTileY;\n            }\n            else if (this.map.renderorder === 'left-up') {\n                tile.sortOrder = -toTileX - this.map.size.x * toTileY;\n            }\n            else if (this.map.renderorder === 'left-down') {\n                tile.sortOrder = -toTileX + this.map.size.x * toTileY;\n            }\n        }\n    }\n\n    // update sprite reference in the map\n    this.tiles[toTileY][toTileX] = tile;\n\n    return tile;\n};\n\n/**\n * Pans the layer around, rendering stuff if necessary\n *\n * @method updatePan\n * @return {Tilelayer} Returns itself.\n * @chainable\n */\nTilelayer.prototype.updatePan = function () {\n    // First, check if we need to build a buffer around the viewport\n    // usually this happens on the first pan after a full render\n    // caused by a viewport resize. We do this buffering here instead\n    // of in the initial render because in the initial render, the buffer\n    // may try to go negative which has no tiles. Plus doing it here\n    // reduces the number of tiles that need to be created initially.\n\n    // moving world right, so left will be exposed\n    if (this._scrollDelta.x > 0 && !this._buffered.left) {\n        this._buffered.left = true;\n        this._renderLeft(true);\n    }\n    // moving world left, so right will be exposed\n    else if (this._scrollDelta.x < 0 && !this._buffered.right) {\n        this._buffered.right = true;\n        this._renderRight(true);\n    }\n\n    // moving world down, so top will be exposed\n    if (this._scrollDelta.y > 0 && !this._buffered.top) {\n        this._buffered.top = true;\n        this._renderUp(true);\n    }\n    // moving world up, so bottom will be exposed\n    else if (this._scrollDelta.y < 0 && !this._buffered.bottom) {\n        this._buffered.bottom = true;\n        this._renderDown(true);\n    }\n\n    // Here is where the actual panning gets done, we check if the pan\n    // delta is greater than a scaled tile and if so pan that direction.\n    // The reason we do it in a while loop is because the delta can be\n    // larger than 1 scaled tile and may require multiple render pans\n    // (this can happen if you can .pan(x, y) with large values)\n\n    var sortRequired = false;\n\n    // moved position right, so render left\n    while (this._scrollDelta.x >= this.map.scaledTileWidth) {\n        this._renderLeft();\n        this._scrollDelta.x -= this.map.scaledTileWidth;\n        sortRequired = true;\n    }\n\n    // moved position left, so render right\n    while (this._scrollDelta.x <= -this.map.scaledTileWidth) {\n        this._renderRight();\n        this._scrollDelta.x += this.map.scaledTileWidth;\n        sortRequired = true;\n    }\n\n    // moved position down, so render up\n    while (this._scrollDelta.y >= this.map.scaledTileHeight) {\n        this._renderUp();\n        this._scrollDelta.y -= this.map.scaledTileHeight;\n        sortRequired = true;\n    }\n\n    // moved position up, so render down\n    while (this._scrollDelta.y <= -this.map.scaledTileHeight) {\n        this._renderDown();\n        this._scrollDelta.y += this.map.scaledTileHeight;\n        sortRequired = true;\n    }\n\n    if (sortRequired) {\n        this.sortTiles();\n    }\n};\n\n/**\n* Gets all tiles that intersect with the given line.\n*\n* @method Phaser.TilemapLayer#getRayCastTiles\n* @memberof Phaser.TilemapLayer\n* @param {Phaser.Line} line - The line used to determine which tiles to return.\n* @param {number} [stepRate] - How many steps through the ray will we check? If undefined or\n*       null it uses TilemapLayer.rayStepRate.\n* @param {boolean} [collides=false] - If true only return tiles that collide on one or more faces.\n* @param {boolean} [interestingFace=false] - If true only return tiles that have interesting faces.\n* @return {array<Phaser.Tile>} An array of Phaser.Tiles.\n*/\nTilelayer.prototype.getRayCastTiles = function (line, stepRate, collides, interestingFace) {\n\n    if (typeof stepRate === 'undefined' || stepRate === null) { stepRate = this.rayStepRate; }\n    if (typeof collides === 'undefined') { collides = false; }\n    if (typeof interestingFace === 'undefined') { interestingFace = false; }\n\n    //  First get all tiles that touch the bounds of the line\n    var tiles = this.getTiles(line.x, line.y, line.width, line.height, collides, interestingFace);\n\n    if (tiles.length === 0)\n    {\n        return tiles;\n    }\n\n    //  Now we only want the tiles that intersect with the points on this line\n    var coords = line.coordinatesOnLine(stepRate);\n    var total = coords.length;\n    var results = [];\n\n    for (var i = 0; i < tiles.length; i++)\n    {\n        for (var t = 0; t < total; t++)\n        {\n            if (tiles[i].containsPoint(coords[t][0], coords[t][1]))\n            {\n                results.push(tiles[i]);\n                break;\n            }\n        }\n    }\n\n    return results;\n\n};\n\n/**\n* Get all tiles that exist within the given area, defined by the top-left corner, width and height.\n* Values given are in pixels, not tiles.\n* @method Phaser.TilemapLayer#getTiles\n* @memberof Phaser.TilemapLayer\n* @param {number} x - X position of the top left corner.\n* @param {number} y - Y position of the top left corner.\n* @param {number} width - Width of the area to get.\n* @param {number} height - Height of the area to get.\n* @param {boolean} [collides=false] - If true only return tiles that collide on one or more faces.\n* @param {boolean} [interestingFace=false] - If true only return tiles that have interesting faces.\n* @return {array<Phaser.Tile>} An array of Phaser.Tiles.\n*/\nTilelayer.prototype.getTiles = function (x, y, width, height, collides, interestingFace) {\n\n    //  Should we only get tiles that have at least one of their collision flags set?\n    // (true = yes, false = no just get them all)\n    if (typeof collides === 'undefined') { collides = false; }\n    if (typeof interestingFace === 'undefined') { interestingFace = false; }\n\n    // adjust the x,y coordinates for scrollFactor\n    // x = this._fixX(x);\n    // y = this._fixY(y);\n\n    if (width > this.widthInPixels)\n    {\n        width = this.widthInPixels;\n    }\n\n    if (height > this.heightInPixels)\n    {\n        height = this.heightInPixels;\n    }\n\n    //  Convert the pixel values into tile coordinates\n    this._mc.tx = this.game.math.snapToFloor(x, this._mc.cw) / this._mc.cw;\n    this._mc.ty = this.game.math.snapToFloor(y, this._mc.ch) / this._mc.ch;\n    this._mc.tw = (this.game.math.snapToCeil(width, this._mc.cw) + this._mc.cw) / this._mc.cw;\n    this._mc.th = (this.game.math.snapToCeil(height, this._mc.ch) + this._mc.ch) / this._mc.ch;\n\n    //  This should apply the layer x/y here\n    var results = [];\n    var tile = null;\n\n    for (var wy = this._mc.ty; wy < this._mc.ty + this._mc.th; wy++)\n    {\n        for (var wx = this._mc.tx; wx < this._mc.tx + this._mc.tw; wx++)\n        {\n            tile = this.getTile(wx, wy);\n            if (tile)\n            {\n                if ((!collides && !interestingFace) || tile.isInteresting(collides, interestingFace))\n                {\n                    results.push(tile);\n                }\n            }\n        }\n    }\n\n    return results;\n\n};\n\nTilelayer.prototype.getTile = function (x, y) {\n    return this.tiles[y] && this.tiles[y][x];\n};\n\n/**\n * Renders tiles to the left, pulling from the far right\n *\n * @method _renderLeft\n * @param [forceNew=false] {Boolean} If set to true, new tiles are created instead of trying to recycle\n * @private\n */\nTilelayer.prototype._renderLeft = function (forceNew) {\n    this._renderArea.x--;\n\n    // move all the far right tiles to the left side\n    for (var i = 0; i < this._renderArea.height; ++i) {\n        this.moveTileSprite(\n            forceNew ? -1 : this._renderArea.right,\n            forceNew ? -1 : this._renderArea.top + i,\n            this._renderArea.left,\n            this._renderArea.top + i\n        );\n    }\n\n    if (forceNew) {\n        this._renderArea.width++;\n    }\n};\n\n/**\n * Renders tiles to the right, pulling from the far left\n *\n * @method _renderRight\n * @param [forceNew=false] {Boolean} If set to true, new tiles are created instead of trying to recycle\n * @private\n */\nTilelayer.prototype._renderRight = function (forceNew) {\n    // move all the far left tiles to the right side\n    for (var i = 0; i < this._renderArea.height; ++i) {\n        this.moveTileSprite(\n            forceNew ? -1 : this._renderArea.left,\n            forceNew ? -1 : this._renderArea.top + i,\n            this._renderArea.right,\n            this._renderArea.top + i\n        );\n    }\n\n    if (!forceNew) {\n        this._renderArea.x++;\n    }\n\n    if (forceNew) {\n        this._renderArea.width++;\n    }\n};\n\n/**\n * Renders tiles to the top, pulling from the far bottom\n *\n * @method _renderUp\n * @param [forceNew=false] {Boolean} If set to true, new tiles are created instead of trying to recycle\n * @private\n */\nTilelayer.prototype._renderUp = function (forceNew) {\n    this._renderArea.y--;\n\n    // move all the far bottom tiles to the top side\n    for (var i = 0; i < this._renderArea.width; ++i) {\n        this.moveTileSprite(\n            forceNew ? -1 : this._renderArea.left + i,\n            forceNew ? -1 : this._renderArea.bottom,\n            this._renderArea.left + i,\n            this._renderArea.top\n        );\n    }\n\n    if (forceNew) {\n        this._renderArea.height++;\n    }\n};\n\n/**\n * Renders tiles to the bottom, pulling from the far top\n *\n * @method _renderDown\n * @param [forceNew=false] {Boolean} If set to true, new tiles are created instead of trying to recycle\n * @private\n */\nTilelayer.prototype._renderDown = function (forceNew) {\n    // move all the far top tiles to the bottom side\n    for (var i = 0; i < this._renderArea.width; ++i) {\n        this.moveTileSprite(\n            forceNew ? -1 : this._renderArea.left + i,\n            forceNew ? -1 : this._renderArea.top,\n            this._renderArea.left + i,\n            this._renderArea.bottom\n        );\n    }\n\n    if (!forceNew) {\n        this._renderArea.y++;\n    }\n\n    if (forceNew) {\n        this._renderArea.height++;\n    }\n};\n\n/**\n * Destroys the tile layer completely\n *\n * @method destroy\n */\nTilelayer.prototype.destroy = function () {\n    this.clearTiles();\n\n    // this will destroy the tile sprites that are children of this group\n    Phaser.Group.prototype.destroy.apply(this, arguments);\n\n    // destroy all the animation textures\n    for (var i = 0; i < this._animTexturePool.length; ++i) {\n        utils.destroyTexture(this._animTexturePool[i]);\n    }\n\n    this._tilePool = null;\n    this._animTexturePool = null;\n\n    this.bodies = null;\n    this.tiles = null;\n\n    this.map = null;\n    this.cameraOffset = null;\n    this.scrollFactor = null;\n\n    this.size = null;\n    this.tileIds = null;\n    this.properties = null;\n\n    this._buffered = null;\n    this._scroll = null;\n    this._scrollDelta = null;\n    this._renderArea = null;\n    this._mc = null;\n\n    this.container = null;\n};\n\nObject.defineProperty(Tilelayer.prototype, 'scrollX', {\n    get: function () {\n        return this._scroll.x;\n    },\n    set: function (value) {\n        if (value !== this._scroll.x) {\n            this._scrollDelta.x -= value - this._scroll.x;\n            this._scroll.x = value;\n        }\n    }\n});\n\nObject.defineProperty(Tilelayer.prototype, 'scrollY', {\n    get: function () {\n        return this._scroll.y;\n    },\n    set: function (value) {\n        if (value !== this._scroll.y) {\n            this._scrollDelta.y -= value - this._scroll.y;\n            this._scroll.y = value;\n        }\n    }\n});\n\nObject.defineProperty(Tilelayer.prototype, 'widthInPixels', {\n    get: function () {\n        return this.size.x * this.map.scaledTileWidth;\n    }\n});\n\nObject.defineProperty(Tilelayer.prototype, 'heightInPixels', {\n    get: function () {\n        return this.size.y * this.map.scaledTileHeight;\n    }\n});\n\n/**\n* @name Phaser.TilemapLayer#collisionWidth\n* @property {number} collisionWidth - The width of the collision tiles.\n*/\nObject.defineProperty(Tilelayer.prototype, 'collisionWidth', {\n\n    get: function () {\n        return this._mc.cw;\n    },\n\n    set: function (value) {\n\n        this._mc.cw = value;\n\n        // this.dirty = true;\n\n    }\n\n});\n\n/**\n* @name Phaser.TilemapLayer#collisionHeight\n* @property {number} collisionHeight - The height of the collision tiles.\n*/\nObject.defineProperty(Tilelayer.prototype, 'collisionHeight', {\n\n    get: function () {\n        return this._mc.ch;\n    },\n\n    set: function (value) {\n\n        this._mc.ch = value;\n\n        // this.dirty = true;\n\n    }\n\n});\n","/home/travis/build/npmtest/node-npmtest-phaser-tiled/node_modules/phaser-tiled/src/tiled/Tilemap.js":"var Tilelayer = require('./Tilelayer');\nvar Objectlayer = require('./Objectlayer');\nvar Tile = require('./Tile');\nvar Tileset = require('./Tileset');\nvar TilemapParser = require('./TilemapParser');\nvar utils = require('../utils');\nvar C = require('../constants');\n\n/**\n * Tiled map that represents an entire tile map with multiple layers or object groups.\n * Often it is easier to create a tilemap using the object factor on a world, rather\n * than doing it manually yourself.\n *\n * @class Tilemap\n * @constructor\n * @param {Phaser.Game} game - Game reference to the currently running game.\n * @param {string} [key] - The name of the tiledmap, this is usually the filename without the extension.\n * @param {Phaser.Group|Phaser.SpriteBatch} [group] - Group to add the tilemap to.\n */\nfunction Tilemap(game, key, group) {\n    Phaser.Group.call(this, game, group, key);\n\n    var data = TilemapParser.parse(game, key);\n\n    this.type = Phaser.TILEMAP;\n\n    /**\n     * The key of this map data in the Phaser.Cache.\n     *\n     * @property key\n     * @type String\n     */\n    this.key = key;\n\n    if (data === null) {\n        return;\n    }\n\n    this.size = new Phaser.Point(data.width, data.height);\n\n    /**\n     * @property {number} tileWidth - The base width of the tiles in the map (in pixels).\n     */\n    this.tileWidth = data.tilewidth;\n\n    /**\n     * @property {number} tileHeight - The base height of the tiles in the map (in pixels).\n     */\n    this.tileHeight = data.tileheight;\n\n    /**\n     * @property {number} scaledTileWidth - The scaled width of the tiles in the map (in pixels).\n     */\n    this.scaledTileWidth = this.tileWidth;\n\n    /**\n     * @property {number} scaledTileHeight - The scaled height of the tiles in the map (in pixels).\n     */\n    this.scaledTileHeight = this.tileHeight;\n\n    /**\n     * @property {string} orientation - The orientation of the map data (as specified in Tiled), usually 'orthogonal'.\n     */\n    this.orientation = data.orientation;\n\n    /**\n     * @property {string} renderorder - The renderorder of the map\n     */\n    this.renderorder = data.renderorder;\n\n    /**\n     * @property {boolean} obeyRenderorder - If true then the map's renderorder will be obeyed.  Defaults to false.\n     */\n    this.obeyRenderorder = false;\n\n    /**\n     * @property {number} format - The format of the map data, either Phaser.Tilemap.CSV or Phaser.Tilemap.TILED_JSON.\n     */\n    this.format = data.format;\n\n    /**\n     * @property {number} version - The version of the map data (as specified in Tiled, usually 1).\n     */\n    this.version = data.version;\n\n    /**\n     * @property {object} properties - Map specific properties as specified in Tiled.\n     */\n    this.properties = utils.parseTiledProperties(data.properties);\n\n    /**\n     * @property {number} widthInPixels - The width of the map in pixels based on width * tileWidth.\n     */\n    this.widthInPixels = data.width * data.tilewidth;\n\n    /**\n     * @property {number} heightInPixels - The height of the map in pixels based on height * tileHeight.\n     */\n    this.heightInPixels = data.height * data.tileheight;\n\n    /**\n     * @property {array} layers - An array of Tilemap layer data.\n     */\n    this.layers = [];\n\n    /**\n     * @property {array} tilesets - An array of Tilesets.\n     */\n    this.tilesets = [];\n\n    /**\n     * @property {array} objects - An array of Tiled Object Layers.\n     */\n    this.objects = [];\n\n    /**\n     * @property {array} images - An array of Tiled Image Layers.\n     */\n    this.images = [];\n\n    /**\n     * @property {array} collideIndexes - An array of tile indexes that collide.\n     */\n    this.collideIndexes = [];\n\n    /**\n     * @property {array} collision - An array of collision data (polylines, etc).\n     */\n    // this.collision = data.collision;\n\n    /**\n     * @property {number} currentLayer - The current layer.\n     */\n    this.currentLayer = 0;\n\n    /**\n     * @property {array} debugMap - Map data used for debug values only.\n     */\n    this.debugMap = [];\n\n    this.preventingRecalculate = false;\n    this.needToRecalculate = null;\n\n    // tell when camera scale is modified\n    this._camScaleX = 0;\n    this._camScaleY = 0;\n\n    // should all layers do a full rerender?\n    this.dirty = true;\n\n    // update the world bounds\n    this.game.world.setBounds(0, 0, this.widthInPixels, this.heightInPixels);\n\n    // create each tileset\n    for (var t = 0, tl = data.tilesets.length; t < tl; ++t) {\n        var ts = data.tilesets[t];\n        this.tilesets.push(new Tileset(game, key, ts));\n    }\n\n    // create each layer\n    for (var i = 0, il = data.layers.length; i < il; ++i) {\n        var lyr;\n        var ldata = data.layers[i];\n\n        switch (ldata.type) {\n            case 'tilelayer':\n                lyr = new Tilelayer(game, this, ldata, this.layers.length);\n                this.layers.push(lyr);\n\n                // calculate the tile faces\n                this.calculateFaces(this.layers.length - 1);\n                break;\n\n            case 'objectgroup':\n                lyr = new Objectlayer(game, this, ldata, this.objects.length);\n                this.objects.push(lyr);\n                break;\n\n            case 'imagelayer':\n                lyr = game.add.sprite(ldata.x, ldata.y, utils.cacheKey(key, 'layer', ldata.name), null, this);\n\n                lyr.visible = ldata.visible;\n                lyr.apha = ldata.opacity;\n\n                this.images.push(lyr);\n                break;\n        }\n    }\n}\n\nTilemap.prototype = Object.create(Phaser.Group.prototype);\nTilemap.prototype.constructor = Tilemap;\n\nmodule.exports = Tilemap;\n\n/**\n * Sets the base tile size for the map.\n *\n * @method setTileSize\n * @param {number} tileWidth - The width of the tiles the map uses for calculations.\n * @param {number} tileHeight - The height of the tiles the map uses for calculations.\n */\nTilemap.prototype.setTileSize = function (tileWidth, tileHeight) {\n    this.tileWidth = tileWidth;\n    this.tileHeight = tileHeight;\n\n    this.scaledTileWidth = tileWidth * this.game.camera.scale.x;\n    this.scaledTileHeight = tileHeight * this.game.camera.scale.y;\n\n    this.widthInPixels = this.width * tileWidth;\n    this.heightInPixels = this.height * tileWidth;\n\n    // update the world bounds\n    this.game.world.setBounds(0, 0, this.width * this.game.camera.scale.x, this.height * this.game.camera.scale.y);\n};\n\n/**\n* Gets the layer index based on the layers name.\n*\n* @method Phaser.Tilemap#getIndex\n* @protected\n* @param {array} location - The local array to search.\n* @param {number|string|object} name - The name of the array element to get.\n* @return {number} The index of the element in the array, or null if not found.\n*/\nTilemap.prototype.getIndex = function (location, name) {\n\n    if (typeof name === 'string') {\n        for (var i = 0; i < location.length; i++)\n        {\n            if (location[i].name === name)\n            {\n                return i;\n            }\n        }\n    }\n    else if (typeof name === 'object') {\n        return name.index;\n    }\n    else if (typeof name === 'number') {\n        return name;\n    }\n\n    return -1;\n\n};\n\n/**\n* Gets the layer index based on its name.\n*\n* @method Phaser.Tilemap#getTilelayerIndex\n* @param {number|string|object} name - The name of the layer to get.\n* @return {number} The index of the layer in this tilemap, or null if not found.\n*/\nTilemap.prototype.getTilelayerIndex = Tilemap.prototype.getLayer = function (name) {\n\n    return this.getIndex(this.layers, name);\n\n};\n\n/**\n* Gets the tileset index based on its name.\n*\n* @method Phaser.Tilemap#getTilesetIndex\n* @param {number|string|object} name - The name of the tileset to get.\n* @return {number} The index of the tileset in this tilemap, or null if not found.\n*/\nTilemap.prototype.getTilesetIndex = function (name) {\n\n    return this.getIndex(this.tilesets, name);\n\n};\n\n/**\n* Gets the image index based on its name.\n*\n* @method Phaser.Tilemap#getImagelayer\n* @param {number|string|object} name - The name of the image to get.\n* @return {number} The index of the image in this tilemap, or null if not found.\n*/\nTilemap.prototype.getImagelayerIndex = function (name) {\n\n    return this.getIndex(this.images, name);\n\n};\n\n/**\n* Gets the object index based on its name.\n*\n* @method Phaser.Tilemap#getObjectlayerIndex\n* @param {number|string|object} name - The name of the object to get.\n* @return {number} The index of the object in this tilemap, or null if not found.\n*/\nTilemap.prototype.getObjectlayerIndex = function (name) {\n\n    return this.getIndex(this.objects, name);\n\n};\n\n/**\n* Gets the layer based on its name.\n*\n* @method Phaser.Tilemap#getTilelayer\n* @param {number|string|object} name - The name of the layer to get.\n* @return {Tilelayer} The index of the layer in this tilemap, or null if not found.\n*/\nTilemap.prototype.getTilelayer = function (name) {\n\n    return this.layers[this.getTilelayerIndex(name)];\n\n};\n\n/**\n* Gets the tileset index based on its name.\n*\n* @method Phaser.Tilemap#getTileset\n* @param {number|string|object} name - The name of the tileset to get.\n* @return {Tileset} The index of the tileset in this tilemap, or null if not found.\n*/\nTilemap.prototype.getTileset = function (name) {\n\n    return this.tilesets[this.getTilesetIndex(name)];\n\n};\n\n/**\n* Gets the image index based on its name.\n*\n* @method Phaser.Tilemap#getImagelayer\n* @param {number|string|object} name - The name of the image to get.\n* @return {Image} The index of the image in this tilemap, or null if not found.\n*/\nTilemap.prototype.getImagelayer = function (name) {\n\n    return this.images[this.getImagelayerIndex(name)];\n\n};\n\n/**\n* Gets the object index based on its name.\n*\n* @method Phaser.Tilemap#getObjectlayer\n* @param {number|string|object} name - The name of the object to get.\n* @return {Objectlayer} The index of the object in this tilemap, or null if not found.\n*/\nTilemap.prototype.getObjectlayer = function (name) {\n\n    return this.objects[this.getObjectlayerIndex(name)];\n\n};\n\n/**\n* Turn off/on the recalculation of faces for tile or collission updates.\n* setPreventRecalculate(true) puts recalculation on hold while\n* setPreventRecalculate(false) recalculates all the changed layers.\n*\n* @method Phaser.Tilemap#setPreventRecalculate\n* @param {boolean} if true it will put the recalculation on hold.\n*/\nTilemap.prototype.setPreventRecalculate = function (value) {\n\n    if ((value === true) && (this.preventingRecalculate !== true))\n    {\n        this.preventingRecalculate = true;\n        this.needToRecalculate = {};\n    }\n\n    if ((value ===  false) && (this.preventingRecalculate === true))\n    {\n        this.preventingRecalculate = false;\n        for (var i in this.needToRecalculate) {\n            this.calculateFaces(i);\n        }\n        this.needToRecalculate = false;\n    }\n\n};\n\n/**\n* Internal function.\n*\n* @method Phaser.Tilemap#calculateFaces\n* @protected\n* @param {number} layer - The index of the TilemapLayer to operate on.\n*/\nTilemap.prototype.calculateFaces = function (layer) {\n\n    if (this.preventingRecalculate)\n    {\n        this.needToRecalculate[layer] = true;\n        return;\n    }\n\n    var above = null;\n    var below = null;\n    var left = null;\n    var right = null;\n\n    for (var y = 0, h = this.layers[layer].size.y; y < h; y++)\n    {\n        for (var x = 0, w = this.layers[layer].size.x; x < w; x++)\n        {\n            var tile = this.layers[layer].tiles[y] ? this.layers[layer].tiles[y][x] : null;\n\n            if (tile)\n            {\n                above = this.getTileAbove(layer, x, y);\n                below = this.getTileBelow(layer, x, y);\n                left = this.getTileLeft(layer, x, y);\n                right = this.getTileRight(layer, x, y);\n\n                if (tile.collides)\n                {\n                    tile.faceTop = true;\n                    tile.faceBottom = true;\n                    tile.faceLeft = true;\n                    tile.faceRight = true;\n                }\n\n                if (above && above.collides)\n                {\n                    //  There is a tile above this one that also collides,\n                    // so the top of this tile is no longer interesting\n                    tile.faceTop = false;\n                }\n\n                if (below && below.collides)\n                {\n                    //  There is a tile below this one that also collides,\n                    // so the bottom of this tile is no longer interesting\n                    tile.faceBottom = false;\n                }\n\n                if (left && left.collides)\n                {\n                    //  There is a tile left this one that also collides,\n                    // so the left of this tile is no longer interesting\n                    tile.faceLeft = false;\n                }\n\n                if (right && right.collides)\n                {\n                    //  There is a tile right this one that also collides,\n                    // so the right of this tile is no longer interesting\n                    tile.faceRight = false;\n                }\n            }\n        }\n    }\n\n};\n\n/**\n* Gets the tile above the tile coordinates given.\n* Mostly used as an internal function by calculateFaces.\n*\n* @method Phaser.Tilemap#getTileAbove\n* @param {number} layer - The local layer index to get the tile from.\n* @param {number} x - The x coordinate to get the tile from. In tiles, not pixels.\n* @param {number} y - The y coordinate to get the tile from. In tiles, not pixels.\n*/\nTilemap.prototype.getTileAbove = function (layer, x, y) {\n\n    if (y > 0)\n    {\n        return this.layers[layer].tiles[y - 1] ? this.layers[layer].tiles[y - 1][x] : null;\n    }\n\n    return null;\n\n};\n\n/**\n* Gets the tile below the tile coordinates given.\n* Mostly used as an internal function by calculateFaces.\n*\n* @method Phaser.Tilemap#getTileBelow\n* @param {number} layer - The local layer index to get the tile from.\n* @param {number} x - The x coordinate to get the tile from. In tiles, not pixels.\n* @param {number} y - The y coordinate to get the tile from. In tiles, not pixels.\n*/\nTilemap.prototype.getTileBelow = function (layer, x, y) {\n\n    if (y < this.layers[layer].height - 1)\n    {\n        return this.layers[layer].tiles[y + 1] ? this.layers[layer].tiles[y + 1][x] : null;\n    }\n\n    return null;\n\n};\n\n/**\n* Gets the tile to the left of the tile coordinates given.\n* Mostly used as an internal function by calculateFaces.\n*\n* @method Phaser.Tilemap#getTileLeft\n* @param {number} layer - The local layer index to get the tile from.\n* @param {number} x - The x coordinate to get the tile from. In tiles, not pixels.\n* @param {number} y - The y coordinate to get the tile from. In tiles, not pixels.\n*/\nTilemap.prototype.getTileLeft = function (layer, x, y) {\n\n    if (x > 0)\n    {\n        return this.layers[layer].tiles[y] ? this.layers[layer].tiles[y][x - 1] : null;\n    }\n\n    return null;\n\n};\n\n/**\n* Gets the tile to the right of the tile coordinates given.\n* Mostly used as an internal function by calculateFaces.\n*\n* @method Phaser.Tilemap#getTileRight\n* @param {number} layer - The local layer index to get the tile from.\n* @param {number} x - The x coordinate to get the tile from. In tiles, not pixels.\n* @param {number} y - The y coordinate to get the tile from. In tiles, not pixels.\n*/\nTilemap.prototype.getTileRight = function (layer, x, y) {\n\n    if (x < this.layers[layer].size.x - 1)\n    {\n        return this.layers[layer].tiles[y] ? this.layers[layer].tiles[y][x + 1] : null;\n    }\n\n    return null;\n\n};\n\n/**\n* Sets the current layer to the given index.\n*\n* @method Phaser.Tilemap#setLayer\n* @param {number|string|Phaser.TilemapLayer} layer - The layer to set as current.\n*/\nTilemap.prototype.setLayer = function (layer) {\n\n    layer = this.getTilelayerIndex(layer);\n\n    if (this.layers[layer])\n    {\n        this.currentLayer = layer;\n    }\n\n};\n\n/**\n* Checks if there is a tile at the given location.\n*\n* @method Phaser.Tilemap#hasTile\n* @param {number} x - X position to check if a tile exists at (given in tile units, not pixels)\n* @param {number} y - Y position to check if a tile exists at (given in tile units, not pixels)\n* @param {number|string|Phaser.TilemapLayer} layer - The layer to set as current.\n* @return {boolean} True if there is a tile at the given location, otherwise false.\n*/\nTilemap.prototype.hasTile = function (x, y, layer) {\n\n    layer = this.getTilelayerIndex(layer);\n\n    return !!(this.layers[layer].tiles[y] ? this.layers[layer].tiles[y][x] : false);\n\n};\n\n/**\n* Removes the tile located at the given coordinates and updates the collision data.\n*\n* @method Phaser.Tilemap#removeTile\n* @param {number} x - X position to place the tile (given in tile units, not pixels)\n* @param {number} y - Y position to place the tile (given in tile units, not pixels)\n* @param {number|string|Phaser.TilemapLayer} [layer] - The layer to modify.\n* @return {Phaser.Tile} The Tile object that was removed from this map.\n*/\nTilemap.prototype.removeTile = function (x, y, layer) {\n\n    layer = this.getTilelayerIndex(layer);\n\n    if (x >= 0 && x < this.layers[layer].size.x && y >= 0 && y < this.layers[layer].size.y)\n    {\n        if (this.hasTile(x, y, layer))\n        {\n            var tile = this.layers[layer].tiles[y][x];\n\n            this.layers[layer].tiles[y][x] = null;\n            this.layers[layer].dirty = true;\n\n            this.calculateFaces(layer);\n\n            return tile;\n        }\n    }\n\n};\n\n/**\n* Removes the tile located at the given coordinates and updates the collision data.\n* The coordinates are given in pixel values.\n*\n* @method Phaser.Tilemap#removeTileWorldXY\n* @param {number} x - X position to remove the tile (given in pixels)\n* @param {number} y - Y position to remove the tile (given in pixels)\n* @param {number} tileWidth - The width of the tile in pixels.\n* @param {number} tileHeight - The height of the tile in pixels.\n* @param {number|string|Phaser.TilemapLayer} [layer] - The layer to modify.\n* @return {Phaser.Tile} The Tile object that was removed from this map.\n*/\nTilemap.prototype.removeTileWorldXY = function (x, y, tileWidth, tileHeight, layer) {\n\n    x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;\n    y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;\n\n    return this.removeTile(x, y, layer);\n\n};\n\n/**\n* Puts a tile of the given index value at the coordinate specified.\n* If you pass `null` as the tile it will pass your call over to Tilemap.removeTile instead.\n*\n* @method Phaser.Tilemap#putTile\n* @param {Phaser.Tile|number|null} tile - The index of this tile to set or a Phaser.Tile object,\n*       null means to remove the tile.\n* @param {number} x - X position to place the tile (given in tile units, not pixels)\n* @param {number} y - Y position to place the tile (given in tile units, not pixels)\n* @param {number|string|Phaser.TilemapLayer} [layer] - The layer to modify.\n* @return {Phaser.Tile} The Tile object that was created or added to this map.\n*/\nTilemap.prototype.putTile = function (tile, x, y, layer) {\n\n    if (tile === null)\n    {\n        return this.removeTile(x, y, layer);\n    }\n\n    layer = this.getTilelayerIndex(layer);\n\n    var tileId;\n    var tileset;\n\n    if (x >= 0 && x < this.layers[layer].size.x && y >= 0 && y < this.layers[layer].size.y)\n    {\n        if (!this.layers[layer].tiles[y]) {\n            this.layers[layer].tiles[y] = {};\n        }\n\n        if (tile instanceof Phaser.Tile)\n        {\n            var idx = (y * this.layers[layer].size.x) + x;\n\n            tileId = this.layers[layer].tileIds[idx];\n            tileset = this.getTileset(tileId);\n\n            if (this.hasTile(x, y, layer))\n            {\n                this.layers[layer].tiles[y][x].copy(tile);\n            }\n            else\n            {\n                this.layers[layer].tiles[y][x] = new Tile(this.game, x, y, tileId, tileset, this.layers[layer]);\n            }\n        }\n        else\n        {\n            tileId = this.layers[layer].tileIds[tile];\n            tileset = this.getTileset(tileId);\n\n            this.layers[layer].tiles[y][x] = null;\n            this.layers[layer].tiles[y][x] = new Tile(this.game, x, y, tileId, tileset, this.layers[layer]);\n        }\n\n        // if (this.collideIndexes.indexOf(index) > -1)\n        // {\n        //     this.layers[layer].tiles[y][x].setCollision(true, true, true, true);\n        // }\n        // else\n        // {\n        //     this.layers[layer].tiles[y][x].resetCollision();\n        // }\n\n        this.layers[layer].dirty = true;\n\n        this.calculateFaces(layer);\n\n        return this.layers[layer].tiles[y][x];\n    }\n\n    return null;\n\n};\n\n/**\n* Puts a tile into the Tilemap layer. The coordinates are given in pixel values.\n*\n* @method Phaser.Tilemap#putTileWorldXY\n* @param {Phaser.Tile|number} tile - The index of this tile to set or a Phaser.Tile object.\n* @param {number} x - X position to insert the tile (given in pixels)\n* @param {number} y - Y position to insert the tile (given in pixels)\n* @param {number} tileWidth - The width of the tile in pixels.\n* @param {number} tileHeight - The height of the tile in pixels.\n* @param {number|string|Phaser.TilemapLayer} [layer] - The layer to modify.\n* @return {Phaser.Tile} The Tile object that was created or added to this map.\n*/\nTilemap.prototype.putTileWorldXY = function (tile, x, y, tileWidth, tileHeight, layer) {\n\n    x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;\n    y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;\n\n    return this.putTile(tile, x, y, layer);\n\n};\n\n/**\n* Gets a tile from the Tilemap Layer. The coordinates are given in tile values.\n*\n* @method Phaser.Tilemap#getTile\n* @param {number} x - X position to get the tile from (given in tile units, not pixels)\n* @param {number} y - Y position to get the tile from (given in tile units, not pixels)\n* @param {number|string|Phaser.TilemapLayer} [layer] - The layer to get the tile from.\n* @param {boolean} [nonNull=false] - If true getTile won't return null for empty tiles,\n*       but a Tile object with an index of -1.\n* @return {Phaser.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.\n*/\nTilemap.prototype.getTile = function (x, y, layer, nonNull) {\n\n    if (typeof nonNull === 'undefined') { nonNull = false; }\n\n    layer = this.getTilelayerIndex(layer);\n\n    if (x >= 0 && x < this.layers[layer].size.x && y >= 0 && y < this.layers[layer].size.y)\n    {\n        return this.layers[layer].tiles[y] ? this.layers[layer].tiles[y][x] : null;\n    }\n\n    return null;\n\n};\n\n/**\n* Gets a tile from the Tilemap layer. The coordinates are given in pixel values.\n*\n* @method Phaser.Tilemap#getTileWorldXY\n* @param {number} x - X position to get the tile from (given in pixels)\n* @param {number} y - Y position to get the tile from (given in pixels)\n* @param {number} [tileWidth] - The width of the tiles. If not given the map default is used.\n* @param {number} [tileHeight] - The height of the tiles. If not given the map default is used.\n* @param {number|string|Phaser.TilemapLayer} [layer] - The layer to get the tile from.\n* @return {Phaser.Tile} The tile at the given coordinates.\n*/\nTilemap.prototype.getTileWorldXY = function (x, y, tileWidth, tileHeight, layer) {\n\n    if (typeof tileWidth === 'undefined') { tileWidth = this.tileWidth; }\n    if (typeof tileHeight === 'undefined') { tileHeight = this.tileHeight; }\n\n    x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;\n    y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;\n\n    return this.getTile(x, y, layer);\n\n};\n\n/**\n* Removes all layers from this tile map.\n*\n* @method Phaser.Tilemap#removeAllLayers\n*/\nTilemap.prototype.removeAllLayers = function () {\n\n    this.layers.length = 0;\n    this.currentLayer = 0;\n\n};\n\n/**\n* Dumps the tilemap data out to the console.\n*\n* @method Phaser.Tilemap#dump\n*/\nTilemap.prototype.dump = function () {\n\n    var txt = '';\n    var args = [''];\n\n    for (var y = 0; y < this.layers[this.currentLayer].size.y; y++)\n    {\n        for (var x = 0; x < this.layers[this.currentLayer].size.x; x++)\n        {\n            txt += '%c  ';\n\n            if (this.layers[this.currentLayer].tiles[y] && this.layers[this.currentLayer].tiles[y][x])\n            {\n                if (this.debugMap[this.layers[this.currentLayer].tiles[y][x]])\n                {\n                    args.push('background: ' + this.debugMap[this.layers[this.currentLayer].tiles[y][x]]);\n                }\n                else\n                {\n                    args.push('background: #ffffff');\n                }\n            }\n            else\n            {\n                args.push('background: rgb(0, 0, 0)');\n            }\n        }\n\n        txt += '\\n';\n    }\n\n    args[0] = txt;\n    console.log.apply(console, args);\n\n};\n\n/**\n * Gets the tileset that an ID is associated with\n *\n * @method getTileset\n * @param tileId {Number} The id of the tile to find the tileset for\n * @return {TiledTileset} Returns the tileset if found, undefined if not\n */\nTilemap.prototype.getTileset = function (tileId) {\n    for (var i = 0, il = this.tilesets.length; i < il; ++i) {\n        if (this.tilesets[i].contains(tileId)) {\n            return this.tilesets[i];\n        }\n    }\n};\n\nTilemap.prototype.postUpdate = function () {\n    if (this._camScaleX !== this.game.camera.scale.x || this._camScaleY !== this.game.camera.scale.y) {\n        this._camScaleX = this.game.camera.scale.x;\n        this._camScaleY = this.game.camera.scale.y;\n\n        this.setTileSize(this.tileWidth, this.tileHeight);\n\n        this.dirty = true;\n    }\n\n    Phaser.Group.prototype.postUpdate.apply(this, arguments);\n\n    this.dirty = false;\n};\n\n/**\n * Spawns all the objects in the ObjectGroups of this map\n *\n * @method spawnObjects\n * @return {Tilemap} Returns itself.\n * @chainable\n */\nTilemap.prototype.spawnObjects = function (spawnCallback) {\n    for (var i = 0, il = this.objects.length; i < il; ++i) {\n        this.objects[i].spawn(spawnCallback);\n    }\n\n    return this;\n};\n\n/**\n * Spawns all the objects in the ObjectGroups of this map\n *\n * @method despawnObjects\n * @return {Tilemap} Returns itself.\n * @chainable\n */\nTilemap.prototype.despawnObjects = function () {\n    for (var i = 0, il = this.objects.length; i < il; ++i) {\n        this.objects[i].despawn();\n    }\n\n    return this;\n};\n\n/**\n * Clears all the tiles that are currently used on all tile layers\n *\n * @method clearTiles\n * @return {Tilemap} Returns itself.\n * @chainable\n */\nTilemap.prototype.clearTiles = function () {\n    for (var i = 0, il = this.layers.length; i < il; ++i) {\n        this.layers[i].clearTiles();\n    }\n\n    return this;\n};\n\n/**\n * Destroys the tilemap instance\n *\n * @method destroy\n */\nTilemap.prototype.destroy = function () {\n    Phaser.Group.prototype.destroy.apply(this, arguments);\n\n    for (var i = 0; i < this.tilesets.length; ++i) {\n        this.tilesets[i].destroy();\n    }\n\n    this.position = null;\n    this.scale = null;\n    this.pivot = null;\n\n    this.key = null;\n    this.size = null;\n    this.tileWidth = null;\n    this.tileHeight = null;\n    this.scaledTileWidth = null;\n    this.scaledTileHeight = null;\n    this.orientation = null;\n    this.format = null;\n    this.version = null;\n    this.properties = null;\n    this.widthInPixels = null;\n    this.heightInPixels = null;\n\n    this.layers = null;\n\n    this.tilesets = null;\n\n    this.objects = null;\n\n    this.images = null;\n\n    this.collideIndexes = null;\n\n    this.debugMap = null;\n\n    this.currentLayer = null;\n    this.preventingRecalculate = null;\n    this.needToRecalculate = null;\n    this._camScaleX = null;\n    this._camScaleY = null;\n    this.dirty = null;\n};\n\n/**\n* @name Phaser.Tilemap#layer\n* @property {number|string|Phaser.TilemapLayer} layer - The current layer object.\n*/\nObject.defineProperty(Tilemap.prototype, 'layer', {\n\n    get: function () {\n\n        return this.layers[this.currentLayer];\n\n    },\n\n    set: function (value) {\n\n        if (value !== this.currentLayer)\n        {\n            this.setLayer(value);\n        }\n\n    }\n\n});\n\nfor (var key in C) {\n    Tilemap[key] = C[key];\n}\n","/home/travis/build/npmtest/node-npmtest-phaser-tiled/node_modules/phaser-tiled/src/tiled/TilemapParser.js":"/* jshint maxlen:200 */\nvar utils = require('../utils');\nvar C = require('../constants');\n\nvar TilemapParser = {\n    /**\n     * Parse tilemap data from the cache and creates a Tilemap object.\n     *\n     * @method parse\n     * @param {Phaser.Game} game - Game reference to the currently running game.\n     * @param {string} key - The key of the tilemap in the Cache.\n     * @param {number} [tileWidth=32] - The pixel width of a single map tile. If using CSV data you must\n     *      specify this. Not required if using Tiled map data.\n     * @param {number} [tileHeight=32] - The pixel height of a single map tile. If using CSV data you must\n     *      specify this. Not required if using Tiled map data.\n     * @param {number} [width=10] - The width of the map in tiles. If this map is created from Tiled or\n     *      CSV data you don't need to specify this.\n     * @param {number} [height=10] - The height of the map in tiles. If this map is created from Tiled or\n     *      CSV data you don't need to specify this.\n     * @return {object} The parsed map object.\n     */\n    parse: function (game, key, tileWidth, tileHeight, width, height) {\n        if (typeof tileWidth === 'undefined') { tileWidth = 32; }\n        if (typeof tileHeight === 'undefined') { tileHeight = 32; }\n        if (typeof width === 'undefined') { width = 10; }\n        if (typeof height === 'undefined') { height = 10; }\n\n        if (typeof key === 'undefined') {\n            return this.getEmptyData();\n        }\n\n        if (!key) {\n            return this.getEmptyData(tileWidth, tileHeight, width, height);\n        }\n\n        var map = game.cache.getTilemapData(utils.cacheKey(key, 'tiledmap'));\n\n        if (map) {\n            if (map.format === C.CSV) {\n                return this.parseCSV(key, map.data, tileWidth, tileHeight);\n            }\n            else if (map.format === C.TILED_XML) {\n                return this.parseTiledXML(map.data);\n            }\n            else if (!map.format || map.format === C.TILED_JSON) {\n                return this.parseTiledJSON(map.data);\n            }\n        }\n        else {\n            console.warn('Phaser.TilemapParser.parse - No map data found for key ' + key);\n        }\n    },\n\n    parseCSV: Phaser.TilemapParser.parseCSV,\n\n    getEmptyData: function () {\n        var map = Phaser.TilemapParser.getEmptyData.apply(this, arguments);\n\n        map.tilewidth = map.tileWidth;\n        map.tileheight = map.tileHeight;\n\n        return map;\n    },\n\n    /**\n     * Parses a Tiled JSON file into valid map data.\n     *\n     * @method parseTiledJSON\n     * @param {object} data - The JSON map data.\n     * @return {object} Generated and parsed map data.\n     */\n    parseTiledJSON: function (data) {\n        if (data.orientation !== 'orthogonal') {\n            console.warn('TilemapParser.parseTiledJSON: Only orthogonal map types are supported in this version of Phaser');\n            return null;\n        }\n\n        data.format = Phaser.TILED_JSON;\n\n        var layers = data.layers;\n\n        // decode any encoded/compressed layers\n        if (Array.isArray(layers)) {\n            for (var i = 0; i < layers.length; i++) {\n                var layer = layers[i];\n\n                if (layer && layer.encoding === 'base64') {\n                    var decomp = utils.decompressBase64Data(layer.data, layer.encoding, layer.compression);\n\n                    layer.data = new Uint32Array(decomp.buffer, 0, decomp.length / 4);\n\n                    // remove metadata as layer is no longer encoded or compressed\n                    delete layer.encoding;\n                    delete layer.compression;\n                }\n            }\n        }\n\n        return data;\n    },\n\n    /**\n     * Parses a Tiled JSON file into valid map data.\n     *\n     * @method parseTiledXML\n     * @param {object} data - The JSON map data.\n     * @return {object} Generated and parsed map data.\n     */\n    parseTiledXML: function (data) {\n        var mapElement = data.getElementsByTagName('map')[0];\n        var map = {\n            version: parseFloat(mapElement.attributes.getNamedItem('version').value, 10),\n            width: parseInt(mapElement.attributes.getNamedItem('width').value, 10),\n            height: parseInt(mapElement.attributes.getNamedItem('height').value, 10),\n            tilewidth: parseInt(mapElement.attributes.getNamedItem('tilewidth').value, 10),\n            tileheight: parseInt(mapElement.attributes.getNamedItem('tileheight').value, 10),\n            orientation: mapElement.attributes.getNamedItem('orientation').value,\n            renderorder: mapElement.attributes.getNamedItem('renderorder').value,\n            format: Phaser.Tilemap.TILED_XML,\n            properties: {},\n            layers: [],\n            tilesets: []\n        };\n        var i = 0;\n        var il = 0;\n\n        // add the properties\n        var mapprops = mapElement.getElementsByTagName('properties');\n        for (i = 0, il = mapprops.length; i < il; ++i) {\n            if (mapprops[i].parentNode === mapElement) {\n                mapprops = mapprops[i].getElementsByTagName('property');\n\n                for (var mp = 0; mp < mapprops.length; ++mp) {\n                    var mappropName = mapprops[mp].attributes.getNamedItem('name').value;\n                    map.properties[mappropName] = mapprops[mp].attributes.getNamedItem('value').value;\n                }\n\n                break;\n            }\n        }\n\n        // add the layers\n        var layers = mapElement.childNodes; // getElementsByTagName('layer');\n\n        for (i = 0, il = layers.length; i < il; ++i) {\n            var node = layers[i];\n\n            if (node.nodeName === 'layer') {\n                var lyr = node;\n                var layer = {\n                    type: 'tilelayer',\n                    name: lyr.attributes.getNamedItem('name').value,\n                    width: parseInt(lyr.attributes.getNamedItem('width').value, 10) || map.width,\n                    height: parseInt(lyr.attributes.getNamedItem('height').value, 10) || map.height,\n                    visible: lyr.attributes.getNamedItem('visible') ? lyr.attributes.getNamedItem('visible').value === '1' : true,\n                    opacity: lyr.attributes.getNamedItem('opacity') ? parseFloat(lyr.attributes.getNamedItem('opacity').value, 10) : 1,\n                    encoding: 'base64',\n                    compression: '',\n                    rawData: '',\n                    data: '',\n                    x: 0,\n                    y: 0\n                };\n\n                // set encoding\n                var dataElement = lyr.getElementsByTagName('data')[0];\n                layer.encoding = dataElement.attributes.getNamedItem('encoding').value;\n\n                // set data from the text node of the element\n                layer.rawData = dataElement.firstChild.nodeValue.trim();\n\n                // set compression\n                if (dataElement.attributes.getNamedItem('compression')) {\n                    layer.compression = dataElement.attributes.getNamedItem('compression').value;\n                }\n\n                if (layer.encoding === 'base64') {\n                    var decomp = utils.decompressBase64Data(layer.rawData, layer.encoding, layer.compression);\n\n                    layer.data = new Uint32Array(decomp.buffer, 0, decomp.length / 4);\n                }\n                else if (layer.encoding === 'csv') {\n                    layer.data = JSON.parse('[' + layer.rawData + ']');\n                }\n\n                map.layers.push(layer);\n            }\n            else if (node.nodeName === 'objectgroup') {\n                var grp = node;\n                var group = {\n                    type: 'objectgroup',\n                    draworder: 'topdown', // TODO: support custom draworders\n                    name: grp.attributes.getNamedItem('name').value,\n                    width: 0,\n                    height: 0,\n                    objects: [],\n                    visible: grp.attributes.getNamedItem('visible') ? grp.attributes.getNamedItem('visible').value === '0' : true,\n                    opacity: grp.attributes.getNamedItem('opacity') ? parseFloat(grp.attributes.getNamedItem('opacity').value, 10) : 1,\n                    x: 0,\n                    y: 0\n                };\n\n                var objects = grp.getElementsByTagName('object');\n                for (var oj = 0; oj < objects.length; ++oj) {\n                    var obj = objects[oj];\n                    var object = {\n                        /* jscs:disable maximumLineLength */\n                        gid: obj.attributes.getNamedItem('gid') ? parseInt(obj.attributes.getNamedItem('gid').value, 10) : null,\n                        name: obj.attributes.getNamedItem('name') ? obj.attributes.getNamedItem('name').value : '',\n                        type: obj.attributes.getNamedItem('type') ? obj.attributes.getNamedItem('type').value : '',\n                        width: obj.attributes.getNamedItem('width') ? parseFloat(obj.attributes.getNamedItem('width').value, 10) : 0,\n                        height: obj.attributes.getNamedItem('height') ? parseFloat(obj.attributes.getNamedItem('height').value, 10) : 0,\n                        rotation: obj.attributes.getNamedItem('rotation') ? parseFloat(obj.attributes.getNamedItem('rotation').value, 10) : 0,\n                        visible: obj.attributes.getNamedItem('visible') ? obj.attributes.getNamedItem('visible').value === '1' : true,\n                        x: parseFloat(obj.attributes.getNamedItem('x').value, 10),\n                        y: parseFloat(obj.attributes.getNamedItem('y').value, 10),\n                        properties: {}\n                        /* jscs:enable maximumLineLength */\n                    };\n                    var poly;\n\n                    if (object.gid === null) {\n                        delete object.gid;\n                    }\n\n                    poly = obj.getElementsByTagName('polygon');\n                    if (poly.length) {\n                        object.polygon = poly[0].attributes.getNamedItem('points').value.split(' ').map(csvToXY);\n                    }\n\n                    poly = obj.getElementsByTagName('polyline');\n                    if (poly.length) {\n                        object.polyline = poly[0].attributes.getNamedItem('points').value.split(' ').map(csvToXY);\n                    }\n\n                    poly = obj.getElementsByTagName('ellipse');\n                    if (poly.length) {\n                        object.ellipse = true;\n                    }\n\n                    var props = obj.getElementsByTagName('properties');\n                    if (props.length) {\n                        props = props[0].getElementsByTagName('property');\n                        for (var pr = 0; pr < props.length; ++pr) {\n                            var propName = props[pr].attributes.getNamedItem('name').value;\n                            object.properties[propName] = props[pr].attributes.getNamedItem('value').value;\n                        }\n                    }\n\n                    group.objects.push(object);\n                }\n\n                map.layers.push(group);\n            }\n            else if (node.nodeName === 'imagelayer') {\n                var ilyr = node;\n                var imglayer = {\n                    type: 'imagelayer',\n                    image: ilyr.getElementsByTagName('image')[0].attributes.getNamedItem('source').value,\n                    name: ilyr.attributes.getNamedItem('name').value,\n                    width: 0, // always 0 for imagelayers\n                    height: 0, // always 0 for imagelayers\n                    visible: ilyr.attributes.getNamedItem('visible') ? ilyr.attributes.getNamedItem('visible').value === '1' : true,\n                    opacity: ilyr.attributes.getNamedItem('opacity') ? parseFloat(ilyr.attributes.getNamedItem('opacity').value, 10) : 1,\n                    x: ilyr.attributes.getNamedItem('x') ? parseInt(ilyr.attributes.getNamedItem('x').value, 10) : 0,\n                    y: ilyr.attributes.getNamedItem('y') ? parseInt(ilyr.attributes.getNamedItem('y').value, 10) : 0,\n                    properties: {}\n                };\n\n                var iprops = ilyr.getElementsByTagName('properties');\n                if (iprops.length) {\n                    iprops = iprops[0].getElementsByTagName('property');\n                    for (var ip = 0; ip < iprops.length; ++ip) {\n                        var ipropName = iprops[ip].attributes.getNamedItem('name').value;\n                        imglayer.properties[ipropName] = iprops[ip].attributes.getNamedItem('value').value;\n                    }\n                }\n\n                map.layers.push(imglayer);\n            }\n        }\n\n        // add the tilesets\n        var tilesets = mapElement.getElementsByTagName('tileset');\n\n        for (i = 0, il = tilesets.length; i < il; ++i) {\n            var tset = tilesets[i];\n            var tiles = tset.getElementsByTagName('tile');\n            var tileset = {\n                name: tset.attributes.getNamedItem('name').value,\n                firstgid: parseInt(tset.attributes.getNamedItem('firstgid').value, 10),\n                tilewidth: parseInt(tset.attributes.getNamedItem('tilewidth').value, 10),\n                tileheight: parseInt(tset.attributes.getNamedItem('tileheight').value, 10),\n                margin: 0,\n                spacing: 0,\n                tileoffset: { x: 0, y: 0 },\n                terrains: [],\n                properties: {},\n                tileproperties: {},\n                tiles: {}\n            };\n\n            // add spacing / margin attributes if exist\n            var spacing = tset.attributes.getNamedItem('spacing');\n            if (spacing) {\n                tileset.spacing = parseInt(spacing.value, 10);\n            }\n\n            var margin = tset.attributes.getNamedItem('margin');\n            if (margin) {\n                tileset.margin = parseInt(margin.value, 10);\n            }\n\n            // add .properties if element exists\n            var tsetprops = tset.getElementsByTagName('properties');\n            for (var tsp = 0; tsp < tsetprops.length; ++tsp) {\n                if (tsetprops[tsp].parentNode === tset) {\n                    tsetprops = tsetprops[tsp].getElementsByTagName('property');\n\n                    if (tsetprops.length) {\n                        for (var p = 0; p < tsetprops.length; ++p) {\n                            var tsetprop = tsetprops[p];\n                            var tsetpropName = tsetprop.attributes.getNamedItem('name').value;\n\n                            tileset.properties[tsetpropName] = tsetprop.attributes.getNamedItem('value').value;\n                        }\n                    }\n\n                    break;\n                }\n            }\n\n            // add .tiles if there are tile-specific properties\n            for (var t = 0; t < tiles.length; ++t) {\n                var tile = tiles[t];\n                var id = tile.attributes.getNamedItem('id').value;\n                var img = tile.getElementsByTagName('image');\n\n                tileset.tiles[id] = {};\n\n                // add attributes into the object\n                for (var ta = 0; ta < tile.attributes.length; ++ta) {\n                    var tileatr = tile.attributes[ta];\n\n                    if (tileatr.name === 'id') {\n                        continue;\n                    }\n\n                    switch (tileatr.name) {\n                        case 'terrain':\n                            tileset.tiles[id].terrain = tileatr.value.sply(',');\n                            break;\n\n                        case 'probability':\n                            tileset.tiles[id].probability = parseFloat(tileatr.value, 10);\n                            break;\n                    }\n                }\n\n                // check if it has an image child\n                if (img.length) {\n                    tileset.tiles[id] = tileset.tiles[id] || {};\n                    tileset.tiles[id].image = img[0].attributes.getNamedItem('source').value;\n                }\n\n                // add all the tile properties\n                var tileprops = tile.getElementsByTagName('properties');\n                if (tileprops.length) {\n                    tileset.tileproperties[id] = {};\n                    tileprops = tileprops[0].getElementsByTagName('property');\n                    for (var tp = 0; tp < tileprops.length; ++tp) {\n                        var tileprop = tileprops[tp];\n                        var tilepropName = tileprop.attributes.getNamedItem('name').value;\n                        tileset.tileproperties[id][tilepropName] = tileprop.attributes.getNamedItem('value').value;\n                    }\n                }\n\n                // add all the tile animations\n                var tileanims = tile.getElementsByTagName('animation');\n                if (tileanims.length) {\n                    tileset.tiles[id].animation = [];\n                    tileanims = tileanims[0].getElementsByTagName('frame');\n                    for (var tn = 0; tn < tileanims.length; ++tn) {\n                        var tileanim = tileanims[tn].attributes;\n                        var animObj = {};\n\n                        for (var tna = 0; tna < tileanim.length; ++tna) {\n                            animObj[tileanim[tna].name] = tileanim[tna].value;\n                        }\n\n                        tileset.tiles[id].animation.push(animObj);\n                    }\n                }\n            }\n\n            // check for terraintypes and add those\n            var terrains = tset.getElementsByTagName('terraintypes');\n            if (terrains.length) {\n                terrains = terrains[0].getElementsByTagName('terrain');\n                for (var tr = 0; tr < terrains.length; ++tr) {\n                    tileset.terrains.push({\n                        name: terrains[tr].attributes.getNamedItem('name').value,\n                        tile: parseInt(terrains[tr].attributes.getNamedItem('tile').value, 10)\n                    });\n                }\n            }\n\n            // check for tileoffset and add that\n            var offset = tset.getElementsByTagName('tileoffset');\n            if (offset.length) {\n                tileset.tileoffset.x = parseInt(offset[0].attributes.getNamedItem('x').value, 10);\n                tileset.tileoffset.y = parseInt(offset[0].attributes.getNamedItem('y').value, 10);\n            }\n\n            // add image, imagewidth, imageheight\n            var image = tset.getElementsByTagName('image');\n            if (image.length === 1 && image[0].parentNode === tset) {\n                tileset.image = image[0].attributes.getNamedItem('source').value;\n                tileset.imagewidth = parseInt(image[0].attributes.getNamedItem('width').value, 10);\n                tileset.imageheight = parseInt(image[0].attributes.getNamedItem('height').value, 10);\n            }\n\n            map.tilesets.push(tileset);\n        }\n\n        return map;\n    }\n};\n\nmodule.exports = TilemapParser;\n\nfunction csvToXY(pt) {\n    var points = pt.split(',');\n    return {\n        x: parseInt(points[0], 10),\n        y: parseInt(points[1], 10)\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-phaser-tiled/node_modules/phaser-tiled/src/tiled/Tileset.js":"var utils = require('../utils');\n\n/**\n * This object represents a tileset used by a Tilemap.\n * There can be multiple Tilesets in a map\n *\n * @class Tileset\n * @extends Texture\n * @constructor\n * @param game {Phaser.Game} Phaser game this belongs to.\n * @param key {string} The name of the tiledmap, this is usually the filename without the extension.\n * @param settings {Object} All the settings for the tileset\n * @param settings.tilewidth {Number} The width of a single tile in the set\n * @param settings.tileheight {Number} The height of a single tile in the set\n * @param [settings.firstgid=1] {Number} The id of the first tile in the set, defaults to 1\n * @param [settings.spacing=0] {Number} The spacing around tiles in the tileset (in pixels)\n * @param [settings.margin=0] {Number} The margin around a tile in the tileset (in pixels)\n * @param [settings.tileoffset] {Object} The offset to apply to a tile rendered from this tileset\n * @param [settings.tileoffset.x=0] {Number} The X offset to apply to the tile\n * @param [settings.tileoffset.y=0] {Number} The Y offset to apply to the tile\n * @param [settings.properties] {Object} User-defined, custom properties that apply to the tileset\n * @param [settings.tileproperties] {Object} User-defined, custom properties that apply to tiles in the tileset.\n *          The keys of this object should the tile id of the properties\n * @param [settings.tiles] {Object} Extra metadata about specific tiles\n * @param [settings.imagewidth] {Number} An override for the image width\n * @param [settings.imageheight] {Number} An override for the image height\n */\n// TODO: Support external tilesets (TSX files) via the \"source\" attribute\n// see: https://github.com/bjorn/tiled/wiki/TMX-Map-Format#tileset\nfunction Tileset(game, key, settings) {\n    var txkey = utils.cacheKey(key, 'tileset', settings.name);\n    var tx = game.cache.getPixiBaseTexture(txkey);\n    var ids;\n    var ttxkey;\n    var ttx;\n    var tileTextures = {};\n    var numTileTextures = 0;\n\n    // if no main texture, check if multi-image tileset\n    if (!tx && settings.tiles) {\n        // need to sort because order matters here, and can't guarantee that the object's keys will be ordered.\n        // We need a custom comparator because .sort() is lexagraphic, not numeric.\n        ids = Object.keys(settings.tiles).sort(function (a, b) { return parseInt(a, 10) - parseInt(b, 10); });\n\n        for (var i = 0; i < ids.length; ++i) {\n            if (settings.tiles[ids[i]].image) {\n                ttxkey = utils.cacheKey(key, 'tileset_image_' + ids[i], settings.name);\n                ttx = game.cache.getPixiTexture(ttxkey);\n\n                if (!ttx) {\n                    console.warn(\n                        'Tileset \"' + settings.name + '\" unable to find texture cached by key \"' +\n                        ttxkey + '\", using blank texture.'\n                    );\n                    ttx = PIXI.Texture.emptyTexture;\n                }\n\n                tileTextures[numTileTextures++] = ttx;\n            }\n        }\n    }\n\n    // if no main texture, and we didn't find any image tiles then warn about blank tileset\n    if (!tx && numTileTextures === 0) {\n        console.warn(\n            'Tileset \"' + settings.name + '\" unable to find texture cached by key \"' +\n            txkey +  '\", using blank texture.'\n        );\n    }\n\n    PIXI.Texture.call(this, tx || PIXI.Texture.emptyTexture.baseTexture);\n\n    this.game = game;\n\n    this.multiImage = numTileTextures > 0;\n\n    // Tiled Editor properties\n\n    /**\n     * The first tileId in the tileset\n     *\n     * @property firstgid\n     * @type Number\n     */\n    this.firstgid = settings.firstgid || 1;\n\n    /**\n     * The name of the tileset\n     *\n     * @property name\n     * @type String\n     */\n    this.name = settings.name;\n\n    /**\n     * The width of a tile in the tileset\n     *\n     * @property tileWidth\n     * @type Number\n     */\n    this.tileWidth = settings.tilewidth;\n\n    /**\n     * The height of a tile in the tileset\n     *\n     * @property tileHeight\n     * @type Number\n     */\n    this.tileHeight = settings.tileheight;\n\n    /**\n     * The spacing around a tile in the tileset\n     *\n     * @property spacing\n     * @type Number\n     */\n    this.spacing = settings.spacing || 0;\n\n    /**\n     * The margin around a tile in the tileset\n     *\n     * @property margin\n     * @type Number\n     */\n    this.margin = settings.margin || 0;\n\n    /**\n     * The offset of tile positions when rendered\n     *\n     * @property tileoffset\n     * @type Phaser.Point\n     */\n    this.tileoffset = new Phaser.Point(\n        settings.tileoffset ? settings.tileoffset.x : 0,\n        settings.tileoffset ? settings.tileoffset.y : 0\n    );\n\n    // TODO: Support for \"terraintypes,\" \"image\"\n    // see: https://github.com/bjorn/tiled/wiki/TMX-Map-Format#tileset\n\n    // Custom/Optional properties\n\n    /**\n     * The number of tiles calculated based on size, margin, and spacing\n     *\n     * @property numTiles\n     * @type Vector\n     */\n    this.numTiles = this.multiImage ? tileTextures.length : new Phaser.Point(\n        Math.round((this.baseTexture.width - this.margin) / (this.tileWidth + this.spacing)),\n        Math.round((this.baseTexture.height - this.margin) / (this.tileHeight + this.spacing))\n    );\n\n    /**\n     * The last tileId in the tileset\n     *\n     * @property lastgid\n     * @type Number\n     */\n    this.lastgid = this.firstgid + (this.multiImage ? numTileTextures : ((this.numTiles.x * this.numTiles.y) || 1)) - 1;\n\n    /**\n     * The properties of the tileset\n     *\n     * @property properties\n     * @type Object\n     */\n    this.properties = utils.parseTiledProperties(settings.properties);\n\n    /**\n     * The properties of the tiles in the tileset\n     *\n     * @property tileproperties\n     * @type Object\n     */\n    this.tileproperties = {};\n\n    // massage tile tileproperties\n    for (var k in settings.tileproperties) {\n        this.tileproperties[k] = utils.parseTiledProperties(settings.tileproperties[k]);\n    }\n\n    /**\n     * The size of the tileset\n     *\n     * @property size\n     * @type Vector\n     */\n    this.size = this.multiImage ? new Phaser.Point(0, 0) : new Phaser.Point(\n        settings.imagewidth || this.baseTexture.width,\n        settings.imageheight || this.baseTexture.height\n    );\n\n    /**\n     * The texture instances for each tile in the set\n     *\n     * @property textures\n     * @type Array\n     */\n    this.textures = this.multiImage ? tileTextures : {};\n\n    /**\n     * The animation data for tile animations in the set\n     *\n     * @property tileanimations\n     * @type Object\n     */\n    this.tileanimations = {};\n\n    /**\n     * Internal tiles config data.\n     *\n     * @property _tilesData\n     * @type Object\n     * @private\n     */\n    this._tilesData = settings.tiles || {};\n}\n\nTileset.prototype = Object.create(PIXI.Texture.prototype);\nTileset.prototype.constructor = Tileset;\n\nmodule.exports = Tileset;\n\n/**\n * Gets the tile properties for a tile based on it's ID\n *\n * @method getTileProperties\n * @param tileId {Number} The id of the tile to get the properties for\n * @return {Object} The properties of the tile\n */\nTileset.prototype.getTileProperties = function (tileId) {\n    if (!tileId) {\n        return null;\n    }\n\n    var flags = Tileset.FLAGS;\n    var flippedX = tileId & flags.FLIPPED_HORZ;\n    var flippedY = tileId & flags.FLIPPED_VERT;\n    var flippedAD = tileId & flags.FLIPPED_ANTI_DIAG;\n\n    tileId = (tileId & ~Tileset.FLAGS.ALL) - this.firstgid;\n\n    // if less than 0, then this id isn't in this tileset\n    if (tileId < 0) {\n        return null;\n    }\n\n    var props = this.tileproperties[tileId] ?\n        // get this value\n        this.tileproperties[tileId] :\n        // set this id to default values and cache\n        this.tileproperties[tileId] = {\n            collides: false\n        };\n\n    props.flippedX = flippedX;\n    props.flippedY = flippedY;\n    props.flippedAD = flippedAD;\n\n    return props;\n};\n\n/**\n * Gets the tile animations for a tile based on it's ID\n *\n * @method getTileProperties\n * @param tileId {Number} The id of the tile to get the animation frames for\n * @return {Phaser.FrameData} The frame data of the tile\n */\nTileset.prototype.getTileAnimations = function (tileId) {\n    if (!tileId) {\n        return null;\n    }\n\n    tileId = (tileId & ~Tileset.FLAGS.ALL) - this.firstgid;\n\n    // if less than 0, then this id isn't in this tileset\n    if (tileId < 0) {\n        return null;\n    }\n\n    // if we have already created the animation data\n    if (this.tileanimations[tileId]) {\n        return this.tileanimations[tileId];\n    }\n\n    if (this._tilesData[tileId] && this._tilesData[tileId].animation) {\n        this.tileanimations[tileId] = {\n            rate: 1000 / this._tilesData[tileId].animation[0].duration,\n            data: new Phaser.FrameData()\n        };\n\n        for (var i = 0; i < this._tilesData[tileId].animation.length; ++i) {\n            var frame = this.getTileTexture(this._tilesData[tileId].animation[i].tileid + this.firstgid).frame;\n\n            this.tileanimations[tileId].data.addFrame(\n                new Phaser.Frame(i, frame.x, frame.y, frame.width, frame.height)\n            );\n        }\n    }\n\n    return null;\n};\n\n/**\n * Gets the tile texture for a tile based on it's ID\n *\n * @method getTileTexture\n * @param tileId {Number} The id of the tile to get the texture for\n * @return {Texture} The texture for the tile\n */\nTileset.prototype.getTileTexture = function (tileId) {\n    if (!tileId) {\n        return null;\n    }\n\n    // get the internal ID of the tile in this set (0 indexed)\n    tileId = (tileId & ~Tileset.FLAGS.ALL) - this.firstgid;\n\n    // if less than 0, then this id isn't in this tileset\n    if (tileId < 0) {\n        return null;\n    }\n\n    // multi image set or we have cached the texture, just return it\n    if (this.multiImage || this.textures[tileId]) {\n        return this.textures[tileId];\n    }\n\n    // generate this tile's texture then cache it.\n    // convert the tileId to x,y coords of the tile in the Texture\n    var y = Phaser.Math.floorTo(tileId / this.numTiles.x);\n    var x = (tileId - (y * this.numTiles.x));\n\n    // get location in pixels\n    x = (x * this.tileWidth) + (x * this.spacing) + this.margin;\n    y = (y * this.tileHeight) + (y * this.spacing) + this.margin;\n\n    return (this.textures[tileId] = new PIXI.Texture(\n        this.baseTexture,\n        new Phaser.Rectangle(x, y, this.tileWidth, this.tileHeight)\n    ));\n};\n\n/**\n * Returns whether or not this tileset contains the given tile guid\n *\n * @method contains\n * @param tileId {Number} The ID of the tile to check\n * @return {Boolean}\n */\nTileset.prototype.contains = function (tileId) {\n    if (!tileId) {\n        return false;\n    }\n\n    tileId &= ~Tileset.FLAGS.ALL;\n\n    return (tileId >= this.firstgid && tileId <= this.lastgid);\n};\n\nTileset.prototype.destroy = function () {\n    utils.destroyTexture(this, false);\n\n    // destroy tile textures\n    for (var id in this.textures) {\n        utils.destroyTexture(this.textures[id]);\n    }\n\n    // destroy tile animations\n    for (var jd in this.tileanimations) {\n        this.tileanimations[jd]._frames = null;\n        this.tileanimations[jd]._frameNames = null;\n    }\n\n    this.tileoffset = null;\n    this.numTiles = null;\n    this.properties = null;\n    this.tileproperties = null;\n    this.size = null;\n    this.textures = null;\n    this.tileanimations = null;\n};\n\n/**\n * Tileset GID flags, these flags are set on a tile's ID to give it a special property\n *\n * @property FLAGS\n * @static\n */\nTileset.FLAGS = {\n    FLIPPED_HORZ: 0x80000000,\n    FLIPPED_VERT: 0x40000000,\n    FLIPPED_ANTI_DIAG: 0x20000000\n};\n\nvar mask = 0;\nfor (var f in Tileset.FLAGS) {\n    mask |= Tileset.FLAGS[f];\n}\n\nTileset.FLAGS.ALL = mask;\n"}